<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Return To Innocence</title>
  
  <subtitle>We should remember what we have done.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fioneragh.github.io/"/>
  <updated>2019-01-16T04:46:38.733Z</updated>
  <id>https://fioneragh.github.io/</id>
  
  <author>
    <name>Fionera</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git ignore file locally</title>
    <link href="https://fioneragh.github.io/2018/11/13/Git-ignore-file-locally/"/>
    <id>https://fioneragh.github.io/2018/11/13/Git-ignore-file-locally/</id>
    <published>2018-11-13T14:22:54.000Z</published>
    <updated>2019-01-16T04:46:38.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x80-新的环境"><a href="#0x80-新的环境" class="headerlink" title="0x80 新的环境"></a>0x80 新的环境</h3><h3 id="0x81-Project-Level-ignore"><a href="#0x81-Project-Level-ignore" class="headerlink" title="0x81 Project-Level ignore"></a>0x81 Project-Level ignore</h3><p>Git应该是目前来讲绝大多数开发人员都在使用VCS工具，Git本身提供分布式的仓库管理，每一个人的repo都可以视为一个仓库，通常它们只在互相同步时有local和remote的差别。</p><p>在我们的日常开发中，往往有很多文件是不属于仓库本身的，比如编译产生的临时文件和开发者自己的本地配置文件。对于这些文件，我们通常会使用GitRoot目录及子目录下的<code>.gitignore</code>文件来忽略我们不想track且untracked的文件。各大代码托管服务在线生成repo时都会提供对应类型项目的ignore模版文件，用于忽略追踪一些常见的文件或目录。</p><p><code>.gitignore</code>设计的初衷是忽略追踪文件，有点<code>assume-unchanged</code>的意思。一个文件如果被ignore且没有被追踪，那我们无论怎样修改这个文件，Git都会忽略掉它，但是如果我们已经将这个文件添加到Stage（通过<code>--force</code>参数）或已经track了这个文件，那.gitignore将不在对该文件生效。</p><a id="more"></a><h3 id="0x82-Global-ignore"><a href="#0x82-Global-ignore" class="headerlink" title="0x82 Global ignore"></a>0x82 Global ignore</h3><p>相对于Project-Level ignore功能，和gitconfig一样，Git本身也提供全局忽略的功能，ignore文件模版与<code>.gitignore</code>文件类似，我们只需要在全局<code>.gitconfig</code>文件（通常在用户Home目录）中指向定义忽略内容的配置文件即可，比如我有一个自己的忽略规则，而这些规则不影响其他人不能将这些配置放到仓库里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    excludesfile = /Users/fionera/.gitignore</span><br></pre></td></tr></table></figure><h3 id="0x83-assume-unchanged"><a href="#0x83-assume-unchanged" class="headerlink" title="0x83 assume-unchanged"></a>0x83 assume-unchanged</h3><p><code>assume-unchanged</code>在前文提到过，字面意思就是假定没有发生变更，从而让Git忽略掉本次修改。比如说我有一个文件需要修改，但是这个文件是被track的，并且这个文件我不想提交从而影响其他人使用，那我可以通过如下命令假定文件没有发生变更：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --assume-unchanged file</span><br></pre></td></tr></table></figure><p>经过这次操作，Git会认为该文件没有本次发生过变更，如果想取消使用<code>--no-assume-unchanged</code>参数即可。如果我认为这个文件只在我本地会修改且不能提交，正常来讲我应该ignore掉这个文件，而<code>.gitignore</code>文件是所有人共用的，我们不能修改这个文件来达到我们的目的。因此我们需要本地的ignore配置来做这件事<code>GitRoot/.git/info/exclude</code>，与上文的全局ignore作用类似，默认情况下它忽略的是untracked的文件，配合<code>assume-unchanged</code>我们就可以模拟出本地忽略一个已经被追踪的文件的修改。</p><p>我们应如何获取哪些文件被我们做了这种处理呢？Git提供了展列各种状态文件的能力，通过如下命令就能检出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -t | grep <span class="string">'^h'</span></span><br></pre></td></tr></table></figure><p>有兴趣可以研究下Git ls-files提供的丰富的参数，其实用的不多。看起来一切很完美，那这样真的能忽略仓库里已经追踪的文件吗？答案是否定的，这也是为什么我用了“本次修改”，其实这种假定变更，一旦HEAD发生变更，<code>assume-unchanged</code>的文件通常会回到变更之前的样子来保证文件真的没有发生变更。对于这种需求，我们应该使用<code>--skip-worktree</code>。</p><h3 id="0x84-skip-worktree"><a href="#0x84-skip-worktree" class="headerlink" title="0x84 skip-worktree"></a>0x84 skip-worktree</h3><p><code>skip-worktree</code>的功能能真正的达到我们的需求，它跳过了worktree对文件的跟踪，它的文件真的变了，这也意味着更新代码也能保持该文件的修改内容，因为拉取代码也会逃过该文件，更意味着当我们使用<code>--no-skip-worktree</code>来恢复跟踪，我们的修改可以被捕捉到，我们可以提交它来做永久的变更</p><p>与<code>assume-unchanged</code>类似，我们可以使用如下命令检出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -v | grep <span class="string">'^S'</span></span><br></pre></td></tr></table></figure><p>对于<code>assume-unchanged</code>和<code>skip-worktree</code>的更多差异以及什么场景下使用哪一种方式，可以参考这个<a href="https://fallengamer.livejournal.com/93321.html" target="_blank" rel="noopener">Summary</a>，前者性能更高，针对一些特殊的场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x80-新的环境&quot;&gt;&lt;a href=&quot;#0x80-新的环境&quot; class=&quot;headerlink&quot; title=&quot;0x80 新的环境&quot;&gt;&lt;/a&gt;0x80 新的环境&lt;/h3&gt;&lt;h3 id=&quot;0x81-Project-Level-ignore&quot;&gt;&lt;a href=&quot;#0x81-Project-Level-ignore&quot; class=&quot;headerlink&quot; title=&quot;0x81 Project-Level ignore&quot;&gt;&lt;/a&gt;0x81 Project-Level ignore&lt;/h3&gt;&lt;p&gt;Git应该是目前来讲绝大多数开发人员都在使用VCS工具，Git本身提供分布式的仓库管理，每一个人的repo都可以视为一个仓库，通常它们只在互相同步时有local和remote的差别。&lt;/p&gt;
&lt;p&gt;在我们的日常开发中，往往有很多文件是不属于仓库本身的，比如编译产生的临时文件和开发者自己的本地配置文件。对于这些文件，我们通常会使用GitRoot目录及子目录下的&lt;code&gt;.gitignore&lt;/code&gt;文件来忽略我们不想track且untracked的文件。各大代码托管服务在线生成repo时都会提供对应类型项目的ignore模版文件，用于忽略追踪一些常见的文件或目录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt;设计的初衷是忽略追踪文件，有点&lt;code&gt;assume-unchanged&lt;/code&gt;的意思。一个文件如果被ignore且没有被追踪，那我们无论怎样修改这个文件，Git都会忽略掉它，但是如果我们已经将这个文件添加到Stage（通过&lt;code&gt;--force&lt;/code&gt;参数）或已经track了这个文件，那.gitignore将不在对该文件生效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://fioneragh.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Android 无法扫描蓝牙设备踩坑</title>
    <link href="https://fioneragh.github.io/2018/09/04/Android-%E6%97%A0%E6%B3%95%E6%89%AB%E6%8F%8F%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E8%B8%A9%E5%9D%91/"/>
    <id>https://fioneragh.github.io/2018/09/04/Android-无法扫描蓝牙设备踩坑/</id>
    <published>2018-09-04T11:15:10.000Z</published>
    <updated>2019-01-16T04:46:38.719Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-从BluetoothLeScanner说起"><a href="#0x81-从BluetoothLeScanner说起" class="headerlink" title="0x81 从BluetoothLeScanner说起"></a>0x81 从BluetoothLeScanner说起</h3><p>早在几年前，Google开始在Android 4.3（Api 18）引入BLE支持的时候，使用的是一套支持不算完善的api，通过BluetoothAdapter的startLeScan方法，传入我们需要接受结果的Callback，这套api到目前为止（Api 28）都是可用的，虽然从Android 5.0开始引入了新的api并且将原来的api标记为废弃。通过观察源码我们可以发现原来的startLerScan已经转换成了BleScanner的api，通过改变原本的实现来保证我们的app仍然可以调用原来的方法并按预期工作。</p><p>Android 4.3甚至4.4对BLE的支持始终比较弱，默认不能作为外围设备不说，通信的稳定性也存在问题。对于4.3之前的设备，更有厂家自行实现Android平台的蓝牙协议栈以提供BLE支持，但是这就会导致最终app的适配十分麻烦且产生碎片化，就像指纹api一样，Android 5.0之后的api则提供了更全面的支持。</p><h3 id="0x82-Android-8-1-Offscreen-Pause-Scanning"><a href="#0x82-Android-8-1-Offscreen-Pause-Scanning" class="headerlink" title="0x82 Android 8.1 Offscreen Pause Scanning"></a>0x82 Android 8.1 Offscreen Pause Scanning</h3><p>如果你使用BLE api搜索周围所有设备，你会发现即使你使用了新的api，在Android 8.1平台上，当你关闭屏幕LogCat会打印类似“pause scanning, need to be resumed”类似的消息，这是因为在Android 8.1这个例行小更新上，Google对BLE的行为再次做了限制，原本Android O上的后台行为限制继续保留，对于无限制无过滤条件（这里指的就是ScanFilter）的扫描，在你关闭屏幕的时候会立即停止。StackOverflow上也有不少人问及这个问题，解决办法就是根据文档对Scanner的描述，在扫描条件中添加ScanFilter，哪怕添加空的，都能规避这一问题。但是有一点要注意，这种行为属于后台行为，应该处理好使用的方式，后台长时间无休止无限制高功率的扫描本身也违背设计规范，并且也不再算是低功耗蓝牙。</p><a id="more"></a><h3 id="0x83-Location-Service对扫描结果的影响"><a href="#0x83-Location-Service对扫描结果的影响" class="headerlink" title="0x83 Location Service对扫描结果的影响"></a>0x83 Location Service对扫描结果的影响</h3><p>这个是真的天坑，我们都知道从Android 6.0（Api 23）开始，Google为了加强用户隐私控制，开始推出动态权限机制，开发人员除了需要在清单文件中指明要使用的feature对应的权限以外，还需要在使用权限的地方动态的获取，用户明确授权之后才能使用。这本身是个很好的设计，但是对于蓝牙伴随而来的有一个改动，就是开启蓝牙某些功能需要定位权限（目前来看粗滤位置与精确位置都可以，对应CORSE_LOCATION和FINE_LOCATION），很多解释是因为新的Beacon设备开始提供地理围栏功能，通过从设备上发送的位置信息可以获取到用户的位置信息，而这种行为属于用户没有授权app获取位置信息，但是你却获取了，于是一刀切，使用蓝牙需要定位权限。</p><p>这一切看起来都算合理，哪怕我们不需要定位，只要和用户做好交互，告知用户我们使用蓝牙通信定位是必须的，都能使之按预期工作，但是往往事情没那么简单，看Google官方的<a href="https://issuetracker.google.com/issues/37065090" target="_blank" rel="noopener">IssueTracker</a>。</p><p>这个行为很有意思，你单单处理好权限是不行的，在文档之外的部分是，在某些设备上，你获取权限并开始了BLE扫描，但是没有任何结果，而这个理由很荒谬的是Location Service没有开启运行，Location Service和定位权限没有直接关系，它是手机用来获取GPS位置的一个服务。包括我的Nexus5测试机从版本MR58K开始就出现了这个问题，而解决办法只有两个：开启定位服务、使用传统蓝牙API扫描设备并使用BLE的api连接和操作设备，其中后者Github有一个库<a href="https://github.com/iDevicesInc/SweetBlue" target="_blank" rel="noopener">SweetBlue</a>做了这种兼容并写了专门的QA。</p><p>参考链接：</p><p><a href="https://github.com/iDevicesInc/SweetBlue/wiki/Android-BLE-Issues" target="_blank" rel="noopener">https://github.com/iDevicesInc/SweetBlue/wiki/Android-BLE-Issues</a><br><a href="https://github.com/AltBeacon/android-beacon-library/issues/301" target="_blank" rel="noopener">https://github.com/AltBeacon/android-beacon-library/issues/301</a></p><p>这个问题到现在依然没有解决，因为它就是这样一种行为，无法从app层面去处理，想要最省事的方式在这种手机上拿到扫描结果，就是开启Location Service。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-从BluetoothLeScanner说起&quot;&gt;&lt;a href=&quot;#0x81-从BluetoothLeScanner说起&quot; class=&quot;headerlink&quot; title=&quot;0x81 从BluetoothLeScanner说起&quot;&gt;&lt;/a&gt;0x81 从BluetoothLeScanner说起&lt;/h3&gt;&lt;p&gt;早在几年前，Google开始在Android 4.3（Api 18）引入BLE支持的时候，使用的是一套支持不算完善的api，通过BluetoothAdapter的startLeScan方法，传入我们需要接受结果的Callback，这套api到目前为止（Api 28）都是可用的，虽然从Android 5.0开始引入了新的api并且将原来的api标记为废弃。通过观察源码我们可以发现原来的startLerScan已经转换成了BleScanner的api，通过改变原本的实现来保证我们的app仍然可以调用原来的方法并按预期工作。&lt;/p&gt;
&lt;p&gt;Android 4.3甚至4.4对BLE的支持始终比较弱，默认不能作为外围设备不说，通信的稳定性也存在问题。对于4.3之前的设备，更有厂家自行实现Android平台的蓝牙协议栈以提供BLE支持，但是这就会导致最终app的适配十分麻烦且产生碎片化，就像指纹api一样，Android 5.0之后的api则提供了更全面的支持。&lt;/p&gt;
&lt;h3 id=&quot;0x82-Android-8-1-Offscreen-Pause-Scanning&quot;&gt;&lt;a href=&quot;#0x82-Android-8-1-Offscreen-Pause-Scanning&quot; class=&quot;headerlink&quot; title=&quot;0x82 Android 8.1 Offscreen Pause Scanning&quot;&gt;&lt;/a&gt;0x82 Android 8.1 Offscreen Pause Scanning&lt;/h3&gt;&lt;p&gt;如果你使用BLE api搜索周围所有设备，你会发现即使你使用了新的api，在Android 8.1平台上，当你关闭屏幕LogCat会打印类似“pause scanning, need to be resumed”类似的消息，这是因为在Android 8.1这个例行小更新上，Google对BLE的行为再次做了限制，原本Android O上的后台行为限制继续保留，对于无限制无过滤条件（这里指的就是ScanFilter）的扫描，在你关闭屏幕的时候会立即停止。StackOverflow上也有不少人问及这个问题，解决办法就是根据文档对Scanner的描述，在扫描条件中添加ScanFilter，哪怕添加空的，都能规避这一问题。但是有一点要注意，这种行为属于后台行为，应该处理好使用的方式，后台长时间无休止无限制高功率的扫描本身也违背设计规范，并且也不再算是低功耗蓝牙。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://fioneragh.github.io/tags/Android/"/>
    
      <category term="BLE" scheme="https://fioneragh.github.io/tags/BLE/"/>
    
  </entry>
  
  <entry>
    <title>利用iMazing修改iOS应用数据</title>
    <link href="https://fioneragh.github.io/2018/08/21/%E5%88%A9%E7%94%A8iMazing%E4%BF%AE%E6%94%B9iOS%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE/"/>
    <id>https://fioneragh.github.io/2018/08/21/利用iMazing修改iOS应用数据/</id>
    <published>2018-08-21T10:57:15.000Z</published>
    <updated>2019-01-16T04:46:38.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-iMazing"><a href="#0x81-iMazing" class="headerlink" title="0x81 iMazing"></a>0x81 iMazing</h3><p><a href="https://imazing.com/" target="_blank" rel="noopener">iMazing</a>是一个第三方iOS设备管理工具，它的功能足够强大，在遵循设备通信协议的前提下提供了足够多的功能，比如单应用数据备份、同步设备数据、访问wrapped文件系统等等。利用iMazing的数据备份功能，我们可以手动修改备份后的数据，然后将修改后的数据还原到手机，从而达到某种目的，比如我们需要修改某些小游戏的数据。</p><h3 id="0x82-备份应用数据"><a href="#0x82-备份应用数据" class="headerlink" title="0x82 备份应用数据"></a>0x82 备份应用数据</h3><p>iOS设备如果没有越狱，是没有办法直接访问设备的文件系统，更不必说是直接修改应用数据。当然，没有拿到root权限的Android也是无法做到的，Android的data分区也是权限分明并且较新的版本上都是采用加密数据存储的方式，我们只能想一些曲线救国的方式。</p><p>iOS11.3的越狱刚出没多久，并且最近的支持直到11.4 beta1，如果越狱过的设备重启还会丢失越狱状态，需要重新操作。为了测试新iOS的特性，我早早讲手头的小8升级到了iOS12，截至文章时间最新测试版是12.0 beta9。iOS12现在想要越狱是不可能的，因此只能找找其他方法，比如先备份再修改然后还原。</p><p>要使用这种方式完成我们的需求，我们要做的第一件是就是对应用数据进行备份。Apple钦定的备份工具是iTunes，但我相信每一个是用过它的人都想吐槽，尤其是老版本，所以它于我的功能也就是同步个自定义铃声，而对于它的备份功能，确实它可以进行备份但是备份的数据是整个手机的使用数据，至少我没有发现合适的方法达到我的要求。于是iMazing出现了，iMazing颜值很高并且提供macOS客户端，简直不能再贴心了，最新版本支持iOS12，正好符合我们的要求。(PS: iMazing提供付费服务，可以完成更多的功能，当然我不太需要，至少免费版目前对我而言够用，当然这里指的是备份还原)</p><p><img src="/images/2018_08_21_01.png" alt="iMazing Home"></p><p>左边Panel上方是我当前连接的手机，下方是之前的备份，这个old backup是连接macOS时itunes备份的，为了方便使用，我又用iMazing备份了一遍，有别于iTunes的备份目录<code>~/Library/Application Support/MobileSync/Backup</code>，iMazing备份在<code>~/Library/Application Support/iMazing/Backups</code>这个目录，弄这么一个备份有个好处，就是备份应用数据时可以选择从旧的备份中导出。以凉屋的Soul Knight为例，我们选择设备的Manage Apps，右键选择<code>Backup App Data</code>：</p><p><img src="/images/2018_08_21_02.png" alt="Backup Data"></p><p>备份导出后而我们便开始修改。</p><a id="more"></a><h3 id="0x83-修改应用数据"><a href="#0x83-修改应用数据" class="headerlink" title="0x83 修改应用数据"></a>0x83 修改应用数据</h3><p>经过前面的操作，我们用iMazing导出了一个imazingapp文件：</p><p><img src="/images/2018_08_21_04.png" alt="zipfile"></p><p><img src="/images/2018_08_21_03.png" alt="imazingapp"></p><p>这个文件其实是个压缩包，我们可以使用zip命令解压，解压后的内容如上图，如果你对macOS应用在<code>~/Library</code>里的组织方式比较熟悉，那你会很自然地理解导出的iOS应用数据的组织关系。我们要修改的文件位于<code>Container/Library/Preferences/</code>目录下，简单的配置数据通常是个plist文件，对于一些文件的savefile也可以自己找寻一下，如果这个文件没有加密，那你可以放心大胆的修改。</p><p>修改完之后，我们把修改后的文件打回imazingapp文件，为了干净我们删掉各级目录的.DS_Store文件：</p><p><img src="/images/2018_08_21_05.png" alt="zip"></p><p>处理完新的imazingapp文件，我们就可以还原数据了。</p><h3 id="0x84-还原应用数据"><a href="#0x84-还原应用数据" class="headerlink" title="0x84 还原应用数据"></a>0x84 还原应用数据</h3><p>还原数据就很简单了，还是之前的应用管理页面，我们右键选择<code>Restore App Data</code>:</p><p><img src="/images/2018_08_21_02.png" alt="Restore Data"></p><p>iMazing，会开始尝试恢复，由于使用的是iTunes的还原机制，因此会要求你关闭Find My iPhone功能，并在回复完成时重启，这里有一点需要注意，重启完成后一定不要急着拔掉数据线连接，由于恢复机制的特殊性，如果提前拔掉，就需要重新进行设备初始化设定，虽然我们的数据不会受影响但是毕竟是麻烦，如果连接设备知道开机，并在iMazing上确认完毕，我们将只需要重新确认一下iCloud条款或者重新登陆一下AppleID以确保云服务的正确使用。</p><p>到此为止，iOS应用的数据修改就完成了，可以游戏作弊了哈哈哈:P</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-iMazing&quot;&gt;&lt;a href=&quot;#0x81-iMazing&quot; class=&quot;headerlink&quot; title=&quot;0x81 iMazing&quot;&gt;&lt;/a&gt;0x81 iMazing&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://imazing.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iMazing&lt;/a&gt;是一个第三方iOS设备管理工具，它的功能足够强大，在遵循设备通信协议的前提下提供了足够多的功能，比如单应用数据备份、同步设备数据、访问wrapped文件系统等等。利用iMazing的数据备份功能，我们可以手动修改备份后的数据，然后将修改后的数据还原到手机，从而达到某种目的，比如我们需要修改某些小游戏的数据。&lt;/p&gt;
&lt;h3 id=&quot;0x82-备份应用数据&quot;&gt;&lt;a href=&quot;#0x82-备份应用数据&quot; class=&quot;headerlink&quot; title=&quot;0x82 备份应用数据&quot;&gt;&lt;/a&gt;0x82 备份应用数据&lt;/h3&gt;&lt;p&gt;iOS设备如果没有越狱，是没有办法直接访问设备的文件系统，更不必说是直接修改应用数据。当然，没有拿到root权限的Android也是无法做到的，Android的data分区也是权限分明并且较新的版本上都是采用加密数据存储的方式，我们只能想一些曲线救国的方式。&lt;/p&gt;
&lt;p&gt;iOS11.3的越狱刚出没多久，并且最近的支持直到11.4 beta1，如果越狱过的设备重启还会丢失越狱状态，需要重新操作。为了测试新iOS的特性，我早早讲手头的小8升级到了iOS12，截至文章时间最新测试版是12.0 beta9。iOS12现在想要越狱是不可能的，因此只能找找其他方法，比如先备份再修改然后还原。&lt;/p&gt;
&lt;p&gt;要使用这种方式完成我们的需求，我们要做的第一件是就是对应用数据进行备份。Apple钦定的备份工具是iTunes，但我相信每一个是用过它的人都想吐槽，尤其是老版本，所以它于我的功能也就是同步个自定义铃声，而对于它的备份功能，确实它可以进行备份但是备份的数据是整个手机的使用数据，至少我没有发现合适的方法达到我的要求。于是iMazing出现了，iMazing颜值很高并且提供macOS客户端，简直不能再贴心了，最新版本支持iOS12，正好符合我们的要求。(PS: iMazing提供付费服务，可以完成更多的功能，当然我不太需要，至少免费版目前对我而言够用，当然这里指的是备份还原)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018_08_21_01.png&quot; alt=&quot;iMazing Home&quot;&gt;&lt;/p&gt;
&lt;p&gt;左边Panel上方是我当前连接的手机，下方是之前的备份，这个old backup是连接macOS时itunes备份的，为了方便使用，我又用iMazing备份了一遍，有别于iTunes的备份目录&lt;code&gt;~/Library/Application Support/MobileSync/Backup&lt;/code&gt;，iMazing备份在&lt;code&gt;~/Library/Application Support/iMazing/Backups&lt;/code&gt;这个目录，弄这么一个备份有个好处，就是备份应用数据时可以选择从旧的备份中导出。以凉屋的Soul Knight为例，我们选择设备的Manage Apps，右键选择&lt;code&gt;Backup App Data&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018_08_21_02.png&quot; alt=&quot;Backup Data&quot;&gt;&lt;/p&gt;
&lt;p&gt;备份导出后而我们便开始修改。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOSm iMazing" scheme="https://fioneragh.github.io/tags/iOSm-iMazing/"/>
    
  </entry>
  
  <entry>
    <title>在macOS Mojave上使用VirtualBox</title>
    <link href="https://fioneragh.github.io/2018/08/01/%E5%9C%A8macOS-Mojave%E4%B8%8A%E4%BD%BF%E7%94%A8VirtualBox/"/>
    <id>https://fioneragh.github.io/2018/08/01/在macOS-Mojave上使用VirtualBox/</id>
    <published>2018-08-01T13:11:10.000Z</published>
    <updated>2019-01-16T04:46:38.793Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-Mojave黑名单"><a href="#0x81-Mojave黑名单" class="headerlink" title="0x81 Mojave黑名单"></a>0x81 Mojave黑名单</h3><p>Mojave对于kext（内和扩展）的加载有黑名单机制，该黑名单记录在一个kext文件中<code>/System/Library/Extensions/AppleKextExcludeList.kext/Contents/Info.plist</code>中，在该plist文件中有一段记录了阻止系统加载的配置：</p><figure class="highlight plist"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>OSKextExcludeList<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>org.virtualbox.kext.VBoxDrv<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>LT 5.2.14<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出在最新版本的Mojave中，系统阻止了低于5.2.14版本的vboxdrv.kext的加载，而这段配置在第一个Mojave的beta版本中是<code>LT 5.3</code>，意味着VirtualBox低于5.3版本的都不能正常使用，而当时VirtualBox的最新版本是5.2.12。在DB发生问题后不久，Oracle放出了5.2.13/14的测试版解决了导致kernel panic的问题，但是系统仍然认为VirtualBox不兼容当前操作系统，所以我们需要做一些修改以让Mojave允许加载。</p><h3 id="0x82-修改VirtualBox"><a href="#0x82-修改VirtualBox" class="headerlink" title="0x82 修改VirtualBox"></a>0x82 修改VirtualBox</h3><p>修改的方式无非两种——修改系统Kext、修改VirtualBox。本着vanilla system的原则，我们不去修改系统文件，因为修改后在系统升级后可能会被覆盖，而软件我们则可以更灵活的控制。VBox的内核扩展有四个：</p><p><img src="/images/2018_08_01_01.png" alt="四个扩展"></p><p>其中VboxDrv.kext是能否启动虚拟机实例的核心，我们通过sed命令修改4个kext的plist：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">''</span> <span class="string">'s/5\.2/5\.3/g'</span> <span class="string">'/Library/Application Support/VirtualBox/VBoxDrv.kext/Contents/Info.plist'</span></span><br><span class="line">sudo sed -i <span class="string">''</span> <span class="string">'s/5\.2/5\.3/g'</span> <span class="string">'/Library/Application Support/VirtualBox/VBoxNetAdp.kext/Contents/Info.plist'</span></span><br><span class="line">sudo sed -i <span class="string">''</span> <span class="string">'s/5\.2/5\.3/g'</span> <span class="string">'/Library/Application Support/VirtualBox/VBoxNetFit.kext/Contents/Info.plist'</span></span><br><span class="line">sudo sed -i <span class="string">''</span> <span class="string">'s/5\.2/5\.3/g'</span> <span class="string">'/Library/Application Support/VirtualBox/VBoxUSB.kext/Contents/Info.plist'</span></span><br><span class="line"></span><br><span class="line">sudo kextload <span class="string">'/Library/Application Support/VirtualBox/VBoxDrv.kext'</span></span><br><span class="line">sudo kextload -d <span class="string">'/Library/Application Support/VirtualBox/VBoxNetAdp.kext'</span></span><br><span class="line">sudo kextload -d <span class="string">'/Library/Application Support/VirtualBox/VBoxNetFit.kext'</span></span><br><span class="line">sudo kextload -d <span class="string">'/Library/Application Support/VirtualBox/VBoxUSB.kext'</span></span><br></pre></td></tr></table></figure><p>命令很简单，我们把4个kext的版本从5.2替换为5.3，然后手动load这几个扩展文件，这样虚拟机实例就可以启动了。</p><p>如果你真的遭遇了VirtualBox不能使用这种情况，你还会发现LaunchPad里的VirtualBox有禁行符号，我们是无法启动VirtualBox Client的，原因很明显，macOS打算杜绝你的相关操作。如果你想启动，我们可以通过<code>/Applications/VirtualBox.app/Contents/MacOS/VirtualBox</code>直接启动VirtualBox的binary文件，他会跳过app文件的检查直接执行。当然还有一个一劳永逸的方法，像修改kext一样修改app的Info.plist:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">''</span> <span class="string">'s/5\.2/5\.3/g'</span> <span class="string">'/Applications/VirtualBox.app/Contents/Info.plist'</span></span><br></pre></td></tr></table></figure><p>这样操作之后，你会发现原本的禁行图标不见了，我们可以像往常一样使用VirtualBox。当然，如文章最开始所显示的那样，新测试版本的Mojave已经将版本限制到5.2.14，也就是说你只要安装最新的VirtualBox（截至文时最新版本5.2.16），并且使用比较新的Mojave就不会有这个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x81-Mojave黑名单&quot;&gt;&lt;a href=&quot;#0x81-Mojave黑名单&quot; class=&quot;headerlink&quot; title=&quot;0x81 Mojave黑名单&quot;&gt;&lt;/a&gt;0x81 Mojave黑名单&lt;/h3&gt;&lt;p&gt;Mojave对于kext（内和扩展）的加载有
      
    
    </summary>
    
    
      <category term="macOS" scheme="https://fioneragh.github.io/tags/macOS/"/>
    
      <category term="VirtualBox" scheme="https://fioneragh.github.io/tags/VirtualBox/"/>
    
  </entry>
  
  <entry>
    <title>macOS误删CoreType</title>
    <link href="https://fioneragh.github.io/2018/07/14/macOS%E8%AF%AF%E5%88%A0CoreTypes/"/>
    <id>https://fioneragh.github.io/2018/07/14/macOS误删CoreTypes/</id>
    <published>2018-07-14T05:57:28.000Z</published>
    <updated>2019-01-16T04:46:38.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-事故背景——完整卸载Xcode"><a href="#0x81-事故背景——完整卸载Xcode" class="headerlink" title="0x81 事故背景——完整卸载Xcode"></a>0x81 事故背景——完整卸载Xcode</h3><p>自High Sierra升级到Mojave后，Xcode也相对应的推出了beta版，一方面因为我不是依赖Xcode的开发者，另一方面Xcode占用的空间是真的大。</p><p>基于以上原因我决定彻底删除Xcode9，只使用Xcode10beta。</p><p>为了给予Xcode10一个相对干净的工作环境，我分别删除了<code>~/Library/Developer</code>、<code>/Library/Developer</code>以及<code>/Application/Xcode.app/</code>下的内容，其中第一个目录是用户使用Xcode产生的辅助文件，第二个目录主要是macOS SDK和CLTool所以我们只删除SDK，第三个是Xcode的本体，里面包含framework和toolchain。删除完后我们使用<code>sudo xcode-select -s %path%</code>设置我们要用的Xcode路径，此时运行Xcode10将会提示安装相应的组件，之后便可以正常使用。</p><h3 id="0x82-bom文件的内容要仔细判断"><a href="#0x82-bom文件的内容要仔细判断" class="headerlink" title="0x82 bom文件的内容要仔细判断"></a>0x82 bom文件的内容要仔细判断</h3><p>正常来讲，经过上述操作，我们应该可以完成Xcode版本的切换，但是事与愿违，在清理Xcode9之前打开了Xcode10并安装了相关组件，我在删除完相关文件后后（其实主要是SDK等相关文件被删除了），导致了Xcode的闪退，猜测macOS记录了Xcode安装的组件，被我直接删除的文件Xcode是不知道的，而我之前执行了组件安装操作，所以Xcode也没有再次弹出安装组件的弹窗，最尴尬的是重新下载Xcode是没有用的。那解决这个问题的办法只有一个了，就是从头模拟一遍Xcode要正常运行需要进行的操作。</p><p>依然是那一个目的，为了给予Xcode10一个相对干净的工作环境，我决定去Receipts下找到经过pkginstaller安装的相关Xcode文件并删除，然后手动安装Xcode10里提供的pkg文件，bom文件里的内容非常多，但是主要集中在<code>/Library/Developer</code>和<code>/System/Library/PrivateFrameworks</code>下。</p><a id="more"></a><h3 id="0x83-悲剧的开始"><a href="#0x83-悲剧的开始" class="headerlink" title="0x83 悲剧的开始"></a>0x83 悲剧的开始</h3><p>bom文件位置：<code>/System/Library/Receipts</code>，我们主要关注<code>com.apple.pkg.MobileDevice.bom</code>、<code>com.apple.pkg.MobileDeviceDevelopment.bom</code>和<code>com.apple.pkg.XcodeSystemResources.bom</code>这三个文件，这个目录下是系统组件的信息，有一些其他的组件感兴趣的可以自己看看。</p><p>使用lsbom命令可以解析bom文件，内容显示pkg释放了哪些文件，我们要做的就是先删除这些文件。</p><p><img src="/images/2018_07_14_01.png" alt="com.apple.pkg.MobileDevice.bom"></p><p>经过分析，我们看到MobileDevice主要向<code>/System/Library/CoreServices/CoreTypes.bundle/Contents/Library/</code>写入了<code>MobileDevices.bundle</code>，向<code>/System/Library/Extensions/</code>写入了<code>AppleMobileDevice.kext</code>、<code>AppleUSBEthernetHost.kext</code>，向<code>/System/Library/LaunchAgents/</code>写入了<code>com.apple.mobiledeviceupdater.plist</code>，向<code>/System/Library/LaunchDaemons/</code>写入了<code>com.apple.usbmuxd.plist</code>，向<code>/System/Library/PrivateFrameworks/</code>写入了<code>AirTrafficHost.framework</code>、<code>DeviceLink.framework</code>、<code>MobileDevice.framework</code>，这些文件主要是用于移动设备支持。悲剧就发上在第一个目录上，CoreServices是系统的基础服务，像是Finder.app就在这个位置，而CoreTypes.bundle内有基础类型的定义，我因为失误不小心删除了整个CoreTypes.bundle，随之而来的就是Finder等系统内置App的崩溃，重启后不显示Dock等问题，完全没办法使用，最后我通过另一台10.13.3设备将CoreTypes打了个tar包，解压到了<code>/System/Library/CoreServices/</code>才得以解决这个问题，虽然系统是Mojave，但是并没有遇到什么大的问题，后面重新下载了PublicBeta全量更新了整个系统，这幕悲剧则彻底结束。</p><p>其实对于<code>com.apple.pkg.MobileDevice.bom</code>和<code>com.apple.pkg.MobileDeviceDevelopment.bom</code>这两部分，他们的内容主要在/S<em>/L</em>，我感觉不应该去，甚至我连它们到底是不是Xcode的组件都不清楚，虽然在Xcode中能找到他们的pkg文件，否则也不会出现这次悲剧。我们看一下XcodeSystemResources：</p><p><img src="/images/2018_07_14_02.png" alt="com.apple.pkg.XcodeSystemResources.bom"></p><p>很明显，内容都在<code>/Library/Developer</code>下，可以放心大胆地删除。</p><h3 id="0x84-手动安装组件"><a href="#0x84-手动安装组件" class="headerlink" title="0x84 手动安装组件"></a>0x84 手动安装组件</h3><p>剩下的工作就很简单了，打开Xcode的资源目录：<code>/Applications/Xcode.app/Contents/Resources/Packages</code>：</p><p><img src="/images/2018_07_14_03.png" alt="Packages"></p><p>我们能看到三个pkg文件，这就是我们刚刚分析三个bom文件对应的安装包，依次安装它们，之后Xcode应该就能正常工作了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-事故背景——完整卸载Xcode&quot;&gt;&lt;a href=&quot;#0x81-事故背景——完整卸载Xcode&quot; class=&quot;headerlink&quot; title=&quot;0x81 事故背景——完整卸载Xcode&quot;&gt;&lt;/a&gt;0x81 事故背景——完整卸载Xcode&lt;/h3&gt;&lt;p&gt;自High Sierra升级到Mojave后，Xcode也相对应的推出了beta版，一方面因为我不是依赖Xcode的开发者，另一方面Xcode占用的空间是真的大。&lt;/p&gt;
&lt;p&gt;基于以上原因我决定彻底删除Xcode9，只使用Xcode10beta。&lt;/p&gt;
&lt;p&gt;为了给予Xcode10一个相对干净的工作环境，我分别删除了&lt;code&gt;~/Library/Developer&lt;/code&gt;、&lt;code&gt;/Library/Developer&lt;/code&gt;以及&lt;code&gt;/Application/Xcode.app/&lt;/code&gt;下的内容，其中第一个目录是用户使用Xcode产生的辅助文件，第二个目录主要是macOS SDK和CLTool所以我们只删除SDK，第三个是Xcode的本体，里面包含framework和toolchain。删除完后我们使用&lt;code&gt;sudo xcode-select -s %path%&lt;/code&gt;设置我们要用的Xcode路径，此时运行Xcode10将会提示安装相应的组件，之后便可以正常使用。&lt;/p&gt;
&lt;h3 id=&quot;0x82-bom文件的内容要仔细判断&quot;&gt;&lt;a href=&quot;#0x82-bom文件的内容要仔细判断&quot; class=&quot;headerlink&quot; title=&quot;0x82 bom文件的内容要仔细判断&quot;&gt;&lt;/a&gt;0x82 bom文件的内容要仔细判断&lt;/h3&gt;&lt;p&gt;正常来讲，经过上述操作，我们应该可以完成Xcode版本的切换，但是事与愿违，在清理Xcode9之前打开了Xcode10并安装了相关组件，我在删除完相关文件后后（其实主要是SDK等相关文件被删除了），导致了Xcode的闪退，猜测macOS记录了Xcode安装的组件，被我直接删除的文件Xcode是不知道的，而我之前执行了组件安装操作，所以Xcode也没有再次弹出安装组件的弹窗，最尴尬的是重新下载Xcode是没有用的。那解决这个问题的办法只有一个了，就是从头模拟一遍Xcode要正常运行需要进行的操作。&lt;/p&gt;
&lt;p&gt;依然是那一个目的，为了给予Xcode10一个相对干净的工作环境，我决定去Receipts下找到经过pkginstaller安装的相关Xcode文件并删除，然后手动安装Xcode10里提供的pkg文件，bom文件里的内容非常多，但是主要集中在&lt;code&gt;/Library/Developer&lt;/code&gt;和&lt;code&gt;/System/Library/PrivateFrameworks&lt;/code&gt;下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="https://fioneragh.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>macOS使用seedutil选择不同的Beta版本</title>
    <link href="https://fioneragh.github.io/2018/06/27/macOS%E4%BD%BF%E7%94%A8seedutil%E9%80%89%E6%8B%A9%E4%B8%8D%E5%90%8C%E7%9A%84Beta%E7%89%88%E6%9C%AC/"/>
    <id>https://fioneragh.github.io/2018/06/27/macOS使用seedutil选择不同的Beta版本/</id>
    <published>2018-06-27T08:55:27.000Z</published>
    <updated>2019-01-16T04:46:38.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-获取macOS的Beta更新"><a href="#0x81-获取macOS的Beta更新" class="headerlink" title="0x81 获取macOS的Beta更新"></a>0x81 获取macOS的Beta更新</h3><p>之前我写过一片获取macOS Developer Beta更新的笔记，<a href="https://fioneragh.github.io/2018/01/31/%E8%8E%B7%E5%8F%96macOS%E7%9A%84DeveloperBeta%E6%9B%B4%E6%96%B0/">获取macOS的DeveloperBeta更新</a>简单剖析了seedutil是如何控制更新的。</p><p>出于一些特殊的需求，我又深入研究一下为什么seedutil的命令执行后会起到这种效果，最终发现根源还在Seeding.framework上。</p><h3 id="0x82-Seeding-framenwork"><a href="#0x82-Seeding-framenwork" class="headerlink" title="0x82 Seeding.framenwork"></a>0x82 Seeding.framenwork</h3><p>如之前说的，macOS内置了Seeding.framework，它提供了seedutil工具来管理beta更新的接收，seedutil的位置：<code>/System/Library/PrivateFrameworks/Seeding.framework/Versions/A/Resources/seedutil</code>，Apple并没有开放链接在<code>/usr/bin</code>下并且该工具执行需要root权限，我们可以使用sudo来使用这个工具。</p><p>我们再看一次seed状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">⇒  sudo /System/Library/PrivateFrameworks/Seeding.framework/Versions/A/Resources/seedutil current</span><br><span class="line">Password:</span><br><span class="line">Currently enrolled <span class="keyword">in</span>: PublicSeed</span><br><span class="line"></span><br><span class="line">Program: 3</span><br><span class="line">Build is seed: YES</span><br><span class="line">CatalogURL: https://swscan.apple.com/content/catalogs/others/index-10.14beta-10.14-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog.gz</span><br><span class="line">NSShowFeedbackMenu: YES</span><br><span class="line">DisableSeedOptOut: NO</span><br></pre></td></tr></table></figure><p>仔细看其实CatalogURL与之前10.13的时候不一样了，没错，这是Mojave配置的地址，其实更新获取的参照就是这个链接，用浏览器打开链接我们会发现它的内容和plist差不多，定义了需要增量更新的标识。</p><a id="more"></a><h3 id="0x83-seedutil-影响的配置文件"><a href="#0x83-seedutil-影响的配置文件" class="headerlink" title="0x83 seedutil 影响的配置文件"></a>0x83 seedutil 影响的配置文件</h3><p>我们都知道，macOS的配置文件主要存放在三个位置：<code>/S*/L*/Preferences</code>、<code>/L*/Preferences</code>和<code>~/L*/Preferences</code>，这三个目录分别存放了系统基本设置、系统软件扩展设置和用户个人设置，而控制获取更新Catalog的文件就是<code>/Library/Preferences/com.apple.SoftwareUpdate.plist</code>：</p><p><img src="/images/2018_06_27_01.png" alt="SoftwareUpdate.plist"></p><p>我们可以看到其中定义了很多操作系统当前版本信息，AppStore或者说softwareupdated使用这些信息来获取系统更新（当然所需的数据远远不止这些），可以看到CatalogURL的值正是我们使用seedutil设置的，当我们unenroll的时候，这个配置文件里的CatalogURL也会被删除。</p><p>如果你仔细观察CustomerBeta、DeveloperBeta和PublicBeta这三个Seed的CatalogURL，你会发现他们是不完全一样的，当然不仅仅是值上，获取的内容也不一样:)</p><h3 id="0x84-Seeding提供的配置"><a href="#0x84-Seeding提供的配置" class="headerlink" title="0x84 Seeding提供的配置"></a>0x84 Seeding提供的配置</h3><p>那这些配置都定义在哪呢，很自然的我们可以想到seedutil所在的位置，我们去Seeding.framework里一探究竟。</p><p><code>/System/Library/PrivateFrameworks/Seeding.framework/Versions/A/Resources/</code>目录全景：</p><p><img src="/images/2018_06_27_02.png" alt="Seeding.framework"></p><p>目下有一个SeedCatalogs.plist文件，它定义了10.14下三个Seed对应的CatalogURL：</p><figure class="highlight plist"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>CustomerSeed<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>https://swscan.apple.com/content/catalogs/others/index-10.14customerseed-10.14-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog.gz<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>DeveloperSeed<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>https://swscan.apple.com/content/catalogs/others/index-10.14seed-10.14-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog.gz<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>PublicSeed<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>https://swscan.apple.com/content/catalogs/others/index-10.14beta-10.14-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog.gz<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>仔细看的话还有一个ObsoleteSeedCatalogs.plist文件，它定义了已废弃的Seed，其中包括可怜的10.13，感兴趣的可以自己看看，这里就不贴了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-获取macOS的Beta更新&quot;&gt;&lt;a href=&quot;#0x81-获取macOS的Beta更新&quot; class=&quot;headerlink&quot; title=&quot;0x81 获取macOS的Beta更新&quot;&gt;&lt;/a&gt;0x81 获取macOS的Beta更新&lt;/h3&gt;&lt;p&gt;之前我写过一片获取macOS Developer Beta更新的笔记，&lt;a href=&quot;https://fioneragh.github.io/2018/01/31/%E8%8E%B7%E5%8F%96macOS%E7%9A%84DeveloperBeta%E6%9B%B4%E6%96%B0/&quot;&gt;获取macOS的DeveloperBeta更新&lt;/a&gt;简单剖析了seedutil是如何控制更新的。&lt;/p&gt;
&lt;p&gt;出于一些特殊的需求，我又深入研究一下为什么seedutil的命令执行后会起到这种效果，最终发现根源还在Seeding.framework上。&lt;/p&gt;
&lt;h3 id=&quot;0x82-Seeding-framenwork&quot;&gt;&lt;a href=&quot;#0x82-Seeding-framenwork&quot; class=&quot;headerlink&quot; title=&quot;0x82 Seeding.framenwork&quot;&gt;&lt;/a&gt;0x82 Seeding.framenwork&lt;/h3&gt;&lt;p&gt;如之前说的，macOS内置了Seeding.framework，它提供了seedutil工具来管理beta更新的接收，seedutil的位置：&lt;code&gt;/System/Library/PrivateFrameworks/Seeding.framework/Versions/A/Resources/seedutil&lt;/code&gt;，Apple并没有开放链接在&lt;code&gt;/usr/bin&lt;/code&gt;下并且该工具执行需要root权限，我们可以使用sudo来使用这个工具。&lt;/p&gt;
&lt;p&gt;我们再看一次seed状态:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;⇒  sudo /System/Library/PrivateFrameworks/Seeding.framework/Versions/A/Resources/seedutil current&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Password:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Currently enrolled &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;: PublicSeed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Program: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Build is seed: YES&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CatalogURL: https://swscan.apple.com/content/catalogs/others/index-10.14beta-10.14-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSShowFeedbackMenu: YES&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DisableSeedOptOut: NO&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;仔细看其实CatalogURL与之前10.13的时候不一样了，没错，这是Mojave配置的地址，其实更新获取的参照就是这个链接，用浏览器打开链接我们会发现它的内容和plist差不多，定义了需要增量更新的标识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="https://fioneragh.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>KabyLake DVMT Fix</title>
    <link href="https://fioneragh.github.io/2018/06/20/KabyLake-DVMT-Fix/"/>
    <id>https://fioneragh.github.io/2018/06/20/KabyLake-DVMT-Fix/</id>
    <published>2018-06-20T10:19:59.000Z</published>
    <updated>2019-01-16T04:46:38.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-Clover"><a href="#0x81-Clover" class="headerlink" title="0x81 Clover"></a>0x81 Clover</h3><p>Hackintosh，这应该是这个系列的第二篇，第一篇参考<a href="https://fioneragh.github.io/2018/03/24/%E5%88%A9%E7%94%A8Hotpatch%E7%A6%81%E7%94%A8DGPU/">利用Hotpatch禁用DGPU</a>主要记录了如何利用Clover禁用部分笔记本未提供BIOS选项的独显。</p><p>Clover，一个强大的引导工具，基于rEFInd魔改而来，提供强大的驱动注入和二进制patch的功能，<a href="https://github.com/RehabMan" target="_blank" rel="noopener">@RehabMan</a>等大牛的参与更是为Clover带来更加强大的诸如AutoMerge等功能，让Clover可以为黑苹果工作的更好。</p><h3 id="0x82-DVMT"><a href="#0x82-DVMT" class="headerlink" title="0x82 DVMT"></a>0x82 DVMT</h3><p>DVMT，全称Dynamic video memory technology，意为动态显存技术，这个显存还不是传统意义上我们在使用显卡的显存，它更像一种预申请用于做缓冲区初始化的存储空间。对于大部分PC厂商来说，BIOS通常会提供一个用于设置大小的选项，而对于很多笔记本来说，BIOS本身提供的选项设置就很少，更别说提供DVMT的设置。</p><p>在比较新的硬件平台上(Broadwell+)，比如我现在使用的KabyLake，也就是7代英特尔CPU，在安装macOS时如果不进行相应的patch，就会导致对应的Framerbuffer程序crash从而导致kernel panic，这是个很致命的问题，因为这个过程发生在你刚引导家在进入系统的时候。究其原因，是因为macOS对于新硬件平台申请了至少64m的prealloc空间，而大部分笔记本设备厂商出厂都设置在32m，当系统想要申请比其大的空间时必然失败，就跟我们平时编程遇到的allocation memory failed是类似的情况，知道问题就知道对应的解决方案了。</p><a id="more"></a><h3 id="0x83-minStolenSize-patch"><a href="#0x83-minStolenSize-patch" class="headerlink" title="0x83 minStolenSize patch"></a>0x83 minStolenSize patch</h3><p>macOS的Framebuffer中有一个非常magic的值——minStolenSize，论坛上叫这个名字我也没有去细查，这个值只要从76修改到EB即能规避DVMT不足的问题，但是貌似他只是修改了检查，而实际上binary向系统申请的值仍然是原值，只是申请这么大空间不一定用得到这么大空间，所以反正能用。</p><p>以10.14 Beta为例，因为这个特征值的确定在10.14发生了修改，我们先找到binary里对应的特征值位置：</p><p><img src="/images/2018_06_20_01.png" alt="minStolenSize位置"></p><p>为了避免不同版本因为某些状况刚好会修改其他的值，我们通常会多添加几个特征字节用来确保这个patch仅在我们已知的情况下起作用，当然用Clover的patch filter也可以做到，但是如果要修改的这组值在ninary理由多个备选，我们就得找到真正影响minStolenSize的地方。介于上述原因，KabyLake平台下的Clover-KextsToPatch中关于minStolenSize的patch通常这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Comment:</span><br><span class="line">minStolenPatch (10.14 Beta1)</span><br><span class="line"></span><br><span class="line">Name:</span><br><span class="line">AppleIntelKBLGraphicsFramebuffer</span><br><span class="line"></span><br><span class="line">Find:</span><br><span class="line">76 46 48 FF 05 BA 48 08</span><br><span class="line"></span><br><span class="line">Repl:</span><br><span class="line">EB 46 48 FF 05 BA 48 08</span><br><span class="line"></span><br><span class="line">Comment:</span><br><span class="line">minStolenPatch (10.14 Beta2)</span><br><span class="line"></span><br><span class="line">Name:</span><br><span class="line">AppleIntelKBLGraphicsFramebuffer</span><br><span class="line"></span><br><span class="line">Find:</span><br><span class="line">76 46 48 FF 05 02 52 08</span><br><span class="line"></span><br><span class="line">Repl:</span><br><span class="line">EB 46 48 FF 05 02 52 08</span><br></pre></td></tr></table></figure><h3 id="0x84-32mb-DVMT-prealloc-patch"><a href="#0x84-32mb-DVMT-prealloc-patch" class="headerlink" title="0x84 32mb DVMT-prealloc patch"></a>0x84 32mb DVMT-prealloc patch</h3><p>minStolenPatch着实是一个不错的方案，我们只要注意找到正确的minStolenSize值并修改，通常就可以正常使用了。不过根据<a href="https://github.com/RehabMan" target="_blank" rel="noopener">RehabMan</a>的说法，这种做法他认为可能会带来一些其他的问题，最好的解决方式还是将macOS认为需要申请64m空间的设置调整到32m，从而保证申请申请与使用的一致性，毕竟我们的笔记本可能真的只有32m的dvmt可分配空间。</p><p>与minStolenPatch的解决思路一致，我们先要找到对应ig-platform-id下的配置信息的二进制位置，然后进行相应的patch。在我们仅仅是安装macOS时，因为不需要硬件加速我们完全可以设置一个根本不存在的platform-id来进入安装界面，此时整个界面都是没有显卡加速的，所以也没有流畅的动画，但是此时我们不需要任何patch就能进入系统，原因也很简单就是因为AppleIntelKBLGraphicsFramebuffer(KabyLake)这个binary所在的kextbundle根本没有加载，自然也不会出现申请内存不足的状况，所以我们还是从AppleIntelKBLGraphicsFramebuffer下手，寻找合适的patch。以10.14 Beta为例，我使用的KabyLake平台的platform-id是0x56160000，搜索结果：</p><p><img src="/images/2018_06_20_02.png" alt="platform-id位置"><br><img src="/images/2018_06_20_03.png" alt="platform-id位置"></p><p>之所以这样修改是因为我已经没办法通过High Sierra的<code>01030303 00002002</code>找到原来的值了，很有可能已经完全变了。根据High Sierra的经验，10.13的KabyLakeFramebuffer的patch是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Comment:</span><br><span class="line">HD620, 32MB BIOS, 19MB framebuffer 9MB cursor bytes 2048MB vram</span><br><span class="line"></span><br><span class="line">Name:</span><br><span class="line">AppleIntelKBLGraphicsFramebuffer</span><br><span class="line"></span><br><span class="line">Find:</span><br><span class="line">01030303 00002002 00000000 00000060</span><br><span class="line"></span><br><span class="line">Repl:</span><br><span class="line">01030303 00003001 00009000 00000080</span><br></pre></td></tr></table></figure><p>内容比较多，但主要分为四块分别是pipe count、framebuffer size、cursor bytes和dmvm，其中第一个通常用来做特征值，第二个是主要的framebuffer大小，第三个cursor的大小，他太小的话通常会导致画面抖动，0x00000000指的是自动，第四个是系统内动态显示内存的最大值，也就是macOS关于信息里的显存大小，加大它可以减少一些花屏幕但作用不是很明显。</p><p>根据之前的信息推测，第二张里是我需要patch的信息，因为我们能在platform-id后找到对应的0x00002002， 指framebuffer的大小为34m，因此我们通过以下patch完成我们需求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Comment:</span><br><span class="line">HD620, 32MB BIOS, 19MB framebuffer 2048MB vram</span><br><span class="line"></span><br><span class="line">Name:</span><br><span class="line">AppleIntelKBLGraphicsFramebuffer</span><br><span class="line"></span><br><span class="line">Find:</span><br><span class="line">200248BA 00000060</span><br><span class="line"></span><br><span class="line">Repl:</span><br><span class="line">300148BA 00000080</span><br></pre></td></tr></table></figure><h3 id="0x85-IntelGraphicsDVMTFixup-required-Lilu"><a href="#0x85-IntelGraphicsDVMTFixup-required-Lilu" class="headerlink" title="0x85 IntelGraphicsDVMTFixup (required Lilu)"></a>0x85 IntelGraphicsDVMTFixup (required Lilu)</h3><p>Clover的patch有一个最致命的地方，想要正确的patch必须已经通过kextcache建立了内核缓存，kextcache执行时将所有已经加载的kext都加到了缓存当中，这样才能被Clover正确的进行二进制替换，具体的原理我没有看Clover的源码，大体意思就是Clover要hook这一过程kext被内核缓存是必须的。因为这些局限，<a href="https://github.com/vit9696" target="_blank" rel="noopener">vit9696</a>写了一个内核扩展，它叫Lilu，通过较早的加载Lilu.kext并加载其他有hook功能的插件kext，这样当系统加载对应kext时可以直接进行patch，这样就可以做到无痛打patch。</p><p>IntelGraphicsDVMTFixup实际上做的事情和上面是一致的，最大的特点就是借助了Lilu的特性。如果你有一定的编程能力，我建议使用这个repo，当macOS新版本发布时自行修改fork的repo编译一个kext来使用，虽然sherlock已经更新了IntelGraphicsDVMTFixup支持了10.14，但我发现他只是修改了Lilu hook的版本匹配以不需要使用<code>-lilubeta*</code>参数来加载它，patch的内容并没有改，可行性我没有测试，不过鉴于很多人都用它应该没什么问题，感兴趣的人可以试试。</p><p>DVMT相关的内容差不多就这些，有其他新的内容我再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-Clover&quot;&gt;&lt;a href=&quot;#0x81-Clover&quot; class=&quot;headerlink&quot; title=&quot;0x81 Clover&quot;&gt;&lt;/a&gt;0x81 Clover&lt;/h3&gt;&lt;p&gt;Hackintosh，这应该是这个系列的第二篇，第一篇参考&lt;a href=&quot;https://fioneragh.github.io/2018/03/24/%E5%88%A9%E7%94%A8Hotpatch%E7%A6%81%E7%94%A8DGPU/&quot;&gt;利用Hotpatch禁用DGPU&lt;/a&gt;主要记录了如何利用Clover禁用部分笔记本未提供BIOS选项的独显。&lt;/p&gt;
&lt;p&gt;Clover，一个强大的引导工具，基于rEFInd魔改而来，提供强大的驱动注入和二进制patch的功能，&lt;a href=&quot;https://github.com/RehabMan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@RehabMan&lt;/a&gt;等大牛的参与更是为Clover带来更加强大的诸如AutoMerge等功能，让Clover可以为黑苹果工作的更好。&lt;/p&gt;
&lt;h3 id=&quot;0x82-DVMT&quot;&gt;&lt;a href=&quot;#0x82-DVMT&quot; class=&quot;headerlink&quot; title=&quot;0x82 DVMT&quot;&gt;&lt;/a&gt;0x82 DVMT&lt;/h3&gt;&lt;p&gt;DVMT，全称Dynamic video memory technology，意为动态显存技术，这个显存还不是传统意义上我们在使用显卡的显存，它更像一种预申请用于做缓冲区初始化的存储空间。对于大部分PC厂商来说，BIOS通常会提供一个用于设置大小的选项，而对于很多笔记本来说，BIOS本身提供的选项设置就很少，更别说提供DVMT的设置。&lt;/p&gt;
&lt;p&gt;在比较新的硬件平台上(Broadwell+)，比如我现在使用的KabyLake，也就是7代英特尔CPU，在安装macOS时如果不进行相应的patch，就会导致对应的Framerbuffer程序crash从而导致kernel panic，这是个很致命的问题，因为这个过程发生在你刚引导家在进入系统的时候。究其原因，是因为macOS对于新硬件平台申请了至少64m的prealloc空间，而大部分笔记本设备厂商出厂都设置在32m，当系统想要申请比其大的空间时必然失败，就跟我们平时编程遇到的allocation memory failed是类似的情况，知道问题就知道对应的解决方案了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="https://fioneragh.github.io/tags/macOS/"/>
    
      <category term="Clover" scheme="https://fioneragh.github.io/tags/Clover/"/>
    
      <category term="Hackintosh" scheme="https://fioneragh.github.io/tags/Hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>设置CrossOver的LANGENV</title>
    <link href="https://fioneragh.github.io/2018/05/14/%E8%AE%BE%E7%BD%AECrossOver%E7%9A%84LANGENV/"/>
    <id>https://fioneragh.github.io/2018/05/14/设置CrossOver的LANGENV/</id>
    <published>2018-05-14T12:48:21.000Z</published>
    <updated>2019-01-16T04:46:38.811Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-CrossOver"><a href="#0x81-CrossOver" class="headerlink" title="0x81 CrossOver"></a>0x81 CrossOver</h3><p>CrossOver是CodeWeaver对Wine稳定版本的一种定制打包。Wine means Wine Is Not an Emulator，意为Wine本身不是一个模拟器，正如其所说的Wine确实不是一个模拟器或虚拟机，它是一个<em>nix兼容层，兼容Windows应用，其主要工作是将Windows系统调用转换为</em>nix系统调用，从而做到在非Windows平台上运行Windows软件。</p><p>Wine是开源且免费的，而CrossOver提供的软件服务不是，CrossOver对常见的Windows软件的运行环境做了预配置，以保证用户进行最少的配置便可以比较稳定的运行软件，但是由于它依赖核心组件Wine，因此通常来讲Wine上游存在的问题它都或多或少地存在。</p><h3 id="0x82-macOS下中文运行环境配置"><a href="#0x82-macOS下中文运行环境配置" class="headerlink" title="0x82 macOS下中文运行环境配置"></a>0x82 macOS下中文运行环境配置</h3><p>其实CrossOver的配置方法有很多，甚至于即使在英文环境下生成的Launcher都可以通过修改plist的方式修改它的运行环境，而今天要说的是通过修改它内置的wine启动脚本来做到这件事情。</p><p>方法很简单，首先找到CrossOver内置Wine的启动脚本位置<code>/Applications/CrossOver.app/Contents/SharedSupport/CrossOver/bin -&gt; /Applications/CrossOver.app/Contents/SharedSupport/CrossOver/CrossOver-Hosted Application</code>，这个目录下有大量的启动脚本，打开wine的perl脚本：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start Wine</span></span><br><span class="line"><span class="keyword">if</span> ($log <span class="keyword">or</span> CXLog::is_on())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">print</span> STDERR <span class="string">"\n** "</span>,<span class="keyword">scalar</span>(<span class="keyword">localtime</span>(<span class="keyword">time</span>)),<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">print</span> STDERR <span class="string">"Starting '"</span>,<span class="keyword">join</span>(<span class="string">"' '"</span>,$cmd,@wine_args),<span class="string">"'\n"</span>;</span><br><span class="line">    <span class="keyword">print</span> STDERR <span class="string">"'"</span>,<span class="keyword">join</span>(<span class="string">"' '"</span>,@args),<span class="string">"'\n\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$ENV<span class="string">&#123;LANG&#125;</span> = <span class="string">"zh_CN.UTF-8"</span>;</span><br><span class="line"><span class="keyword">exec</span> $cmd, @wine_args, @args</span><br><span class="line"><span class="keyword">or</span> cxerr(<span class="string">"unable to start '$cmd': $!\n"</span>);</span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其中在试用exec执行外部命令之前，添加一句<code>$ENV{LANG} = &quot;zh_CN.UTF-8&quot;;</code>便可以讲LANGENV设置为”zh_CN.UTF-8”，之后启动CrossOver并启动对应的Windows应用时，便会通过wine脚本正确的启动到对应的语言环境。不过这里我遇到一个问题，对于中文的显示没什么问题，但是导出到剪贴板的中文会全部乱码，应该还是字符集的问题，找个时间扒扒原因，ANSI下的Windows字符真的很不友好。</p><a id="more"></a><h3 id="0x83-macOS自带的语言环境设置"><a href="#0x83-macOS自带的语言环境设置" class="headerlink" title="0x83 macOS自带的语言环境设置"></a>0x83 macOS自带的语言环境设置</h3><p>曾几何时，操作系统便一致使用英文，作为一只合格的猴子，熟悉并接纳英文的开发环境我觉得还是有必要的。在使用macOS之后（其实很多Linux软件也是这样），在系统设置为英文时，软件所采用的默认语言也是英文并且通常不提供设置，而实际上很多macOS软件尤其是自带的软件在中英文环境下会存在功能上的差异，比如日历的农历仅在中文环境下显示（iOS最让我诟病的地方）。那么在macOS上有没有办法强制或者说欺骗软件使用我们指定的运行环境呢？起始官方提供了支持，那就是<code>-AppleLanguages</code>参数，用法很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -a CrossOver --args -AppleLanguages <span class="string">'(zh_CN)'</span> <span class="comment"># 其中zh_CN是在.app/Contents/Resources中可以找到的对应的资源</span></span><br></pre></td></tr></table></figure><p>当然如果我们一直想通过Dock或LaunchPad启动，可以将脚本写到脚本编辑器然后导出Application就可以了，当然还有个办法，可以通过default（类似dbus）直接设定应用的配置，这里就不赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-CrossOver&quot;&gt;&lt;a href=&quot;#0x81-CrossOver&quot; class=&quot;headerlink&quot; title=&quot;0x81 CrossOver&quot;&gt;&lt;/a&gt;0x81 CrossOver&lt;/h3&gt;&lt;p&gt;CrossOver是CodeWeaver对Wine稳定版本的一种定制打包。Wine means Wine Is Not an Emulator，意为Wine本身不是一个模拟器，正如其所说的Wine确实不是一个模拟器或虚拟机，它是一个&lt;em&gt;nix兼容层，兼容Windows应用，其主要工作是将Windows系统调用转换为&lt;/em&gt;nix系统调用，从而做到在非Windows平台上运行Windows软件。&lt;/p&gt;
&lt;p&gt;Wine是开源且免费的，而CrossOver提供的软件服务不是，CrossOver对常见的Windows软件的运行环境做了预配置，以保证用户进行最少的配置便可以比较稳定的运行软件，但是由于它依赖核心组件Wine，因此通常来讲Wine上游存在的问题它都或多或少地存在。&lt;/p&gt;
&lt;h3 id=&quot;0x82-macOS下中文运行环境配置&quot;&gt;&lt;a href=&quot;#0x82-macOS下中文运行环境配置&quot; class=&quot;headerlink&quot; title=&quot;0x82 macOS下中文运行环境配置&quot;&gt;&lt;/a&gt;0x82 macOS下中文运行环境配置&lt;/h3&gt;&lt;p&gt;其实CrossOver的配置方法有很多，甚至于即使在英文环境下生成的Launcher都可以通过修改plist的方式修改它的运行环境，而今天要说的是通过修改它内置的wine启动脚本来做到这件事情。&lt;/p&gt;
&lt;p&gt;方法很简单，首先找到CrossOver内置Wine的启动脚本位置&lt;code&gt;/Applications/CrossOver.app/Contents/SharedSupport/CrossOver/bin -&amp;gt; /Applications/CrossOver.app/Contents/SharedSupport/CrossOver/CrossOver-Hosted Application&lt;/code&gt;，这个目录下有大量的启动脚本，打开wine的perl脚本：&lt;/p&gt;
&lt;figure class=&quot;highlight perl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Start Wine&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ($log &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; CXLog::is_on())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; STDERR &lt;span class=&quot;string&quot;&gt;&quot;\n** &quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;scalar&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;localtime&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;time&lt;/span&gt;)),&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; STDERR &lt;span class=&quot;string&quot;&gt;&quot;Starting &#39;&quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;&#39; &#39;&quot;&lt;/span&gt;,$cmd,@wine_args),&lt;span class=&quot;string&quot;&gt;&quot;&#39;\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; STDERR &lt;span class=&quot;string&quot;&gt;&quot;&#39;&quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;&#39; &#39;&quot;&lt;/span&gt;,@args),&lt;span class=&quot;string&quot;&gt;&quot;&#39;\n\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ENV&lt;span class=&quot;string&quot;&gt;&amp;#123;LANG&amp;#125;&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;zh_CN.UTF-8&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;exec&lt;/span&gt; $cmd, @wine_args, @args&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; cxerr(&lt;span class=&quot;string&quot;&gt;&quot;unable to start &#39;$cmd&#39;: $!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中在试用exec执行外部命令之前，添加一句&lt;code&gt;$ENV{LANG} = &amp;quot;zh_CN.UTF-8&amp;quot;;&lt;/code&gt;便可以讲LANGENV设置为”zh_CN.UTF-8”，之后启动CrossOver并启动对应的Windows应用时，便会通过wine脚本正确的启动到对应的语言环境。不过这里我遇到一个问题，对于中文的显示没什么问题，但是导出到剪贴板的中文会全部乱码，应该还是字符集的问题，找个时间扒扒原因，ANSI下的Windows字符真的很不友好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="https://fioneragh.github.io/tags/macOS/"/>
    
      <category term="CrossOver" scheme="https://fioneragh.github.io/tags/CrossOver/"/>
    
  </entry>
  
  <entry>
    <title>霓虹之行</title>
    <link href="https://fioneragh.github.io/2018/05/10/%E9%9C%93%E8%99%B9%E4%B9%8B%E8%A1%8C/"/>
    <id>https://fioneragh.github.io/2018/05/10/霓虹之行/</id>
    <published>2018-05-10T13:37:08.000Z</published>
    <updated>2019-01-16T04:46:38.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x80-劳累的旅行"><a href="#0x80-劳累的旅行" class="headerlink" title="0x80 劳累的旅行"></a>0x80 劳累的旅行</h3><p>其实这场旅行的收获很大，虽然很累（每天2万多步对我来说几乎是一周的步量）但是足够充实。</p><p>自从3月份辞职以来，我一直全身心的投入到新的工作生活当中去，每天都是加班加点地工作，想着既然重新出来闯，出来跟着他们创业本身就是一件十分有挑战性的事情。新公司寄于大CML庇护之下，努力萌发自己的产品，当然无尽的工作压力也在蚕食我的健康，但拼一拼才会知道自己的极限在哪里。</p><p>算一算有接近两个月的时间没有记录一下学习工作生活了，Github也荒了一段时间（虽然大部分都是刷README:P），出于工作比较累的原因，仅有的一天周末休息时间也几乎全用来睡觉，所以51小假期一来便果断请了两天假，飞去日本感受了一下奢靡的资本主义生活。</p><p>不得不说岛国的空气是真的好，至少比青岛好太多，大清早的起床整个街道上给人的感觉就不一样。去日本这几天住在领导她哥家，省了不少钱不说，这种在外居家的感觉绝对是酒店给不了的，羡慕小别墅=。=</p><h3 id="0x79-风雾纪实"><a href="#0x79-风雾纪实" class="headerlink" title="0x79 风雾纪实"></a>0x79 风雾纪实</h3><p>此程感悟最大的不是去时日本的万里晴空和归时青岛的阴雨连绵，而是错综复杂的日本铁路网，什么乱七八糟的私铁、地铁、JR高铁线搞得我晕头转向。第一天晚上做SkyLiner站内再购票差点就留在成田机场，回来那天的京成本线也是强行等了半个小时以为会赶不上飞机，说真的，京都和成天机场隔得还是有点远的。。。不过玩的这几天只依靠铁路交通工具的感觉还是很微妙的，没有去不到的地方，对比刚通2/3/11号线地铁轻轨的青岛尤为明显。</p><p>还有，女人买东西是真的可怕😨，遇到免税、折扣这种东西，的确省了很多钱，但是不得不说一次性买那么多以至于担心行李超重我之前是确实想不到的，不过我领导最后给我剩了1000日元，因为所有的药妆基本都是刷的卡😊，然后，药妆店如松本清全特么是中国人。</p><p>于我而言，我什么也没买，只买了个微小的Switch，免税加Union的折扣大约等于白送了个新星同盟，当然其实还买了林克传说，好了先到这我去找呀哈哈了～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x80-劳累的旅行&quot;&gt;&lt;a href=&quot;#0x80-劳累的旅行&quot; class=&quot;headerlink&quot; title=&quot;0x80 劳累的旅行&quot;&gt;&lt;/a&gt;0x80 劳累的旅行&lt;/h3&gt;&lt;p&gt;其实这场旅行的收获很大，虽然很累（每天2万多步对我来说几乎是一周的步量）但是
      
    
    </summary>
    
    
      <category term="Ordinary" scheme="https://fioneragh.github.io/tags/Ordinary/"/>
    
  </entry>
  
  <entry>
    <title>利用Hotpatch禁用DGPU</title>
    <link href="https://fioneragh.github.io/2018/03/24/%E5%88%A9%E7%94%A8Hotpatch%E7%A6%81%E7%94%A8DGPU/"/>
    <id>https://fioneragh.github.io/2018/03/24/利用Hotpatch禁用DGPU/</id>
    <published>2018-03-24T07:12:53.000Z</published>
    <updated>2019-01-16T04:46:38.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-Clover-Hotpatch"><a href="#0x81-Clover-Hotpatch" class="headerlink" title="0x81 Clover-Hotpatch"></a>0x81 Clover-Hotpatch</h3><p>Hackintosh，这应该是这个系列的第一篇，黑苹果的折腾笔记绝对可以写本书，只是拿不出这么多的时间来做这件事情。</p><p>Clover，一个强大的引导工具，基于rEFInd魔改而来，提供强大的驱动注入和二进制patch的功能，<a href="https://github.com/RehabMan" target="_blank" rel="noopener">@RehabMan</a>等大牛的参与更是为Clover带来更加强大的诸如AutoMerge等功能，让Clover可以为黑苹果工作的更好。</p><p>Hotpatch，字面意思热补丁，主要是对于Clover强大的ACPI修改功能的支持，将hackintosh复杂而繁琐的ACPI修改中解放出来，从而实现patch像DSDT设备改名等功能。Hotpatch能做到DSDT/SSDT对象命名，插入补丁，方法重定向，方法重写等功能，通过灵活的扩展SSDT文件，我们只要自己学会ACPI汇编的语法从而会阅读aml文件经过iasl反汇编的dsl源文件，便可以完成自己想做的任何事。当然这个过程看起来容易，往往需要大量的基础知识和充分的测试才能写出能够使用的Hotpatch文件。</p><h3 id="0x82-High-Sierra-对WindowServer的修改"><a href="#0x82-High-Sierra-对WindowServer的修改" class="headerlink" title="0x82 High Sierra 对WindowServer的修改"></a>0x82 High Sierra 对WindowServer的修改</h3><p>macOS由于自身独特的封闭性，所以对传统laptop的DGPU并没有提供足够的支持，尤其是nVidia显卡。纵使nVidia官方提供了macOS可用的WebDriver来驱动我们的GT显卡，但是这些驱动往往是提供给桌面级独立GPU使用的。</p><p>在10.13之前，包括10.12，我们可以通过nv_diable参数禁用macOS对DGPU显卡进行驱动，当然这样也只是禁止了驱动的加载，在设备上电时仍会消耗电池资源。真正正确的做法是对SSDT/DSDT进行修改，通过_OFF方法禁用显卡，这种修改方式有一个很棘手的问题，就是EC，大量的笔记本（Lenovo几乎全系）有EmbeddedController，通过它来进行设备的电源管理。在我们在调用_OFF方法时EC可能还没准备好，因此我们需要将代码段里的方法转移到REG（具体的我没仔细研究）中来保证正常的工作。</p><p>到了10.13，系统底层做了大量的修改，尤其是显卡驱动部分，就像10.11的USB栈重写，nv_disable参数已经失效，系统在监测到设备会尝试进行驱动，由于根本无法驱动DGPU，所以WindowServer会出现“Window Server Service only ran for 0 seconds”的提示，其实如果能看到完整的log你就会发现WindowServer的确起不来，服务运行0s也就说得通了。</p><p>之前禁用独立显卡的方法仍然有效，但是在引导安装器阶段可能会遇到问题，于是RehabMan出了篇教程<a href="https://www.tonymacx86.com/threads/fix-window-server-service-only-ran-for-0-seconds-with-dual-gpu.233092/" target="_blank" rel="noopener">[FIX] “Window Server Service only ran for 0 seconds” with dual-GPU</a>就是解决这个问题。这篇教程通过DeviceSpecificMethod注入了一些属性，其实作用和Clover的Devices/AddProperties作用类似，有机会做个对比。</p><a id="more"></a><h3 id="0x83-SSDT-DDGPU-dsl"><a href="#0x83-SSDT-DDGPU-dsl" class="headerlink" title="0x83 SSDT-DDGPU.dsl"></a>0x83 SSDT-DDGPU.dsl</h3><p>这时候Hotpatch大放异彩，我们只需要写一个简单的dsl文件并将它编译后的aml文件置入@EFI/EFI/Clover/ACPI/patched当中就可以起到禁用DGPU的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// For disabling the discrete GPU</span><br><span class="line"></span><br><span class="line">DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;_DDGPU&quot;, 0)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: The _OFF path should be customized to correspond to your native ACPI</span><br><span class="line">    // the two paths provided here should be considered examples only</span><br><span class="line">    // it is best to edit the code such that only the single _OFF path that your ACPI</span><br><span class="line">    // uses is included.</span><br><span class="line">    External(_SB.PCI0.PEG0.PEGP._OFF, MethodObj)</span><br><span class="line">    External(_SB.PCI0.PEGP.DGFX._OFF, MethodObj)</span><br><span class="line"></span><br><span class="line">    Device(RMD1)</span><br><span class="line">    &#123;</span><br><span class="line">        Name(_HID, &quot;RMD10000&quot;)</span><br><span class="line">        Method(_INI)</span><br><span class="line">        &#123;</span><br><span class="line">            // disable discrete graphics (Nvidia/Radeon) if it is present</span><br><span class="line">            If (CondRefOf(\_SB.PCI0.PEG0.PEGP._OFF)) &#123; \_SB.PCI0.PEG0.PEGP._OFF() &#125;</span><br><span class="line">            If (CondRefOf(\_SB.PCI0.PEGP.DGFX._OFF)) &#123; \_SB.PCI0.PEGP.DGFX._OFF() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//EOF</span><br></pre></td></tr></table></figure><p>代码没多少，引用了外部的方法，定义了新的设备RMD1，这个抽象的设备就做了一件事，在_INI方法设备初始化的时候检查饮用的方法有没有定义，定义了就执行。其中的PEGP和DGFX通常指代nVidia/Radeon设备，而PCI0后的路径使设备作用域路径。</p><p>设备路径很好找，在我们之前iasl反汇编的dsl文件中过滤_OFF方法就能找到，比如<code>grep -l Method.*_OFF *.dsl</code>结果可能是SSDT-5.dsl，进去找到正确的路径位置就行。</p><h3 id="0x84-Collection-Of-Some"><a href="#0x84-Collection-Of-Some" class="headerlink" title="0x84 Collection Of Some"></a>0x84 Collection Of Some</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Intel ACPI Component Architecture</span><br><span class="line"> * AML/ASL+ Disassembler version 20161210-64(RM)</span><br><span class="line"> * Copyright (c) 2000 - 2016 Intel Corporation</span><br><span class="line"> * </span><br><span class="line"> * Disassembling to non-symbolic legacy ASL operators</span><br><span class="line"> *</span><br><span class="line"> * Disassembly of iASLZEyCG3.aml, Sat Mar 24 15:48:25 2018</span><br><span class="line"> *</span><br><span class="line"> * Original Table Header:</span><br><span class="line"> *     Signature        &quot;SSDT&quot;</span><br><span class="line"> *     Length           0x000004E9 (1257)</span><br><span class="line"> *     Revision         0x02</span><br><span class="line"> *     Checksum         0xDD</span><br><span class="line"> *     OEM ID           &quot;hack&quot;</span><br><span class="line"> *     OEM Table ID     &quot;spoof&quot;</span><br><span class="line"> *     OEM Revision     0x00000000 (0)</span><br><span class="line"> *     Compiler ID      &quot;INTL&quot;</span><br><span class="line"> *     Compiler Version 0x20161210 (538317328)</span><br><span class="line"> */</span><br><span class="line">DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;_DDGPU&quot;, 0x00000000)</span><br><span class="line">&#123;</span><br><span class="line">    External (_SB_.PCI0.PEG0.PEGP._OFF, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.PEG0.PEGP._ON_, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.PEG2.PEGP._OFF, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.PEG2.PEGP._ON_, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.PEGP.DGFX._OFF, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.PEGP.DGFX._ON_, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.PEG_.VID_._PS0, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.PEG_.VID_._PS3, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.PEG_.VID_.XDSM, MethodObj)    // 4 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.RP01.PEGP._OFF, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.RP01.PEGP._ON_, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.RP01.PXSX._OFF, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.RP01.PXSX._ON_, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.RP05.PXSX._OFF, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line">    External (_SB_.PCI0.RP05.PXSX._ON_, MethodObj)    // 0 Arguments (from opcode)</span><br><span class="line"></span><br><span class="line">    Device (DGPU)</span><br><span class="line">    &#123;</span><br><span class="line">        Name (_HID, &quot;DGPU1000&quot;)  // _HID: Hardware ID</span><br><span class="line">        Name (RMEN, One)</span><br><span class="line">        Method (_INI, 0, NotSerialized)  // _INI: Initialize</span><br><span class="line">        &#123;</span><br><span class="line">            _OFF ()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method (_ON, 0, NotSerialized)  // _ON_: Power On</span><br><span class="line">        &#123;</span><br><span class="line">            If (CondRefOf (\_SB.PCI0.PEG0.PEGP._ON))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.PEG2.PEGP._ON ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.PEG2.PEGP._ON))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.PEG0.PEGP._ON ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.PEGP.DGFX._ON))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.PEGP.DGFX._ON ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.PEG.VID._PS0))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.PEG.VID._PS0 ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.RP01.PEGP._ON))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.RP01.PEGP._ON ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.RP01.PXSX._ON))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.RP01.PXSX._ON ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.RP05.PXSX._ON))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.RP05.PXSX._ON ()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method (_OFF, 0, NotSerialized)  // _OFF: Power Off</span><br><span class="line">        &#123;</span><br><span class="line">            If (CondRefOf (\_SB.PCI0.PEG0.PEGP._OFF))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.PEG2.PEGP._OFF ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.PEG2.PEGP._OFF))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.PEG0.PEGP._OFF ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.PEGP.DGFX._OFF))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.PEGP.DGFX._OFF ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.PEG.VID._PS3))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.PEG.VID.XDSM (ToUUID (&quot;a486d8f8-0bda-471b-a72b-6042a6b5bee0&quot;), 0x0100, 0x1A, Buffer (0x04)</span><br><span class="line">                    &#123;</span><br><span class="line">                         0x01, 0x00, 0x00, 0x03</span><br><span class="line">                    &#125;)</span><br><span class="line">                \_SB.PCI0.PEG.VID._PS3 ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.RP01.PEGP._OFF))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.RP01.PEGP._OFF ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.RP01.PXSX._OFF))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.RP01.PXSX._OFF ()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If (CondRefOf (\_SB.PCI0.RP05.PXSX._OFF))</span><br><span class="line">            &#123;</span><br><span class="line">                \_SB.PCI0.RP05.PXSX._OFF ()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多人可能有疑虑，为什么这里_OFF方法可以放心调用，我猜测是因为Hotpatch的SSDT是在最后才将设备挂上，而不是像之前的_INI方法调用比较早，有可能EC还没准备好，所以需要将EC的调用放到确保EC已经准备好的位置。</p><p>目前为止，配合正确的config文件和驱动你应该已经能看到Installer了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-Clover-Hotpatch&quot;&gt;&lt;a href=&quot;#0x81-Clover-Hotpatch&quot; class=&quot;headerlink&quot; title=&quot;0x81 Clover-Hotpatch&quot;&gt;&lt;/a&gt;0x81 Clover-Hotpatch&lt;/h3&gt;&lt;p&gt;Hackintosh，这应该是这个系列的第一篇，黑苹果的折腾笔记绝对可以写本书，只是拿不出这么多的时间来做这件事情。&lt;/p&gt;
&lt;p&gt;Clover，一个强大的引导工具，基于rEFInd魔改而来，提供强大的驱动注入和二进制patch的功能，&lt;a href=&quot;https://github.com/RehabMan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@RehabMan&lt;/a&gt;等大牛的参与更是为Clover带来更加强大的诸如AutoMerge等功能，让Clover可以为黑苹果工作的更好。&lt;/p&gt;
&lt;p&gt;Hotpatch，字面意思热补丁，主要是对于Clover强大的ACPI修改功能的支持，将hackintosh复杂而繁琐的ACPI修改中解放出来，从而实现patch像DSDT设备改名等功能。Hotpatch能做到DSDT/SSDT对象命名，插入补丁，方法重定向，方法重写等功能，通过灵活的扩展SSDT文件，我们只要自己学会ACPI汇编的语法从而会阅读aml文件经过iasl反汇编的dsl源文件，便可以完成自己想做的任何事。当然这个过程看起来容易，往往需要大量的基础知识和充分的测试才能写出能够使用的Hotpatch文件。&lt;/p&gt;
&lt;h3 id=&quot;0x82-High-Sierra-对WindowServer的修改&quot;&gt;&lt;a href=&quot;#0x82-High-Sierra-对WindowServer的修改&quot; class=&quot;headerlink&quot; title=&quot;0x82 High Sierra 对WindowServer的修改&quot;&gt;&lt;/a&gt;0x82 High Sierra 对WindowServer的修改&lt;/h3&gt;&lt;p&gt;macOS由于自身独特的封闭性，所以对传统laptop的DGPU并没有提供足够的支持，尤其是nVidia显卡。纵使nVidia官方提供了macOS可用的WebDriver来驱动我们的GT显卡，但是这些驱动往往是提供给桌面级独立GPU使用的。&lt;/p&gt;
&lt;p&gt;在10.13之前，包括10.12，我们可以通过nv_diable参数禁用macOS对DGPU显卡进行驱动，当然这样也只是禁止了驱动的加载，在设备上电时仍会消耗电池资源。真正正确的做法是对SSDT/DSDT进行修改，通过_OFF方法禁用显卡，这种修改方式有一个很棘手的问题，就是EC，大量的笔记本（Lenovo几乎全系）有EmbeddedController，通过它来进行设备的电源管理。在我们在调用_OFF方法时EC可能还没准备好，因此我们需要将代码段里的方法转移到REG（具体的我没仔细研究）中来保证正常的工作。&lt;/p&gt;
&lt;p&gt;到了10.13，系统底层做了大量的修改，尤其是显卡驱动部分，就像10.11的USB栈重写，nv_disable参数已经失效，系统在监测到设备会尝试进行驱动，由于根本无法驱动DGPU，所以WindowServer会出现“Window Server Service only ran for 0 seconds”的提示，其实如果能看到完整的log你就会发现WindowServer的确起不来，服务运行0s也就说得通了。&lt;/p&gt;
&lt;p&gt;之前禁用独立显卡的方法仍然有效，但是在引导安装器阶段可能会遇到问题，于是RehabMan出了篇教程&lt;a href=&quot;https://www.tonymacx86.com/threads/fix-window-server-service-only-ran-for-0-seconds-with-dual-gpu.233092/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[FIX] “Window Server Service only ran for 0 seconds” with dual-GPU&lt;/a&gt;就是解决这个问题。这篇教程通过DeviceSpecificMethod注入了一些属性，其实作用和Clover的Devices/AddProperties作用类似，有机会做个对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="https://fioneragh.github.io/tags/macOS/"/>
    
      <category term="Clover" scheme="https://fioneragh.github.io/tags/Clover/"/>
    
      <category term="Hackintosh" scheme="https://fioneragh.github.io/tags/Hackintosh/"/>
    
      <category term="Hotpatch" scheme="https://fioneragh.github.io/tags/Hotpatch/"/>
    
      <category term="ACPI" scheme="https://fioneragh.github.io/tags/ACPI/"/>
    
  </entry>
  
  <entry>
    <title>辞工作的日子</title>
    <link href="https://fioneragh.github.io/2018/03/20/%E8%BE%9E%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%97%A5%E5%AD%90/"/>
    <id>https://fioneragh.github.io/2018/03/20/辞工作的日子/</id>
    <published>2018-03-20T11:45:15.000Z</published>
    <updated>2019-01-16T04:46:38.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x80-迷途不知返"><a href="#0x80-迷途不知返" class="headerlink" title="0x80 迷途不知返"></a>0x80 迷途不知返</h3><p>转眼一看年都过去一个月了，这半个月来的生活真的是相当不容易。去年没有总结，但去年算是学习的一年（每一年都在学习=。=），随着2018的到来，事情也逐渐多了起来。</p><p>说句实在话，之前呆的公司自始至终都不是我想要的，它没有向我想象的方向发展，也没有给到我应得的东西。在公司我最看重的就是自己所在的团队，自己虽然非常努力维护团队的利益，努力营造一个足够好的学术氛围，即使是在面试上招人上都尽可能的谨慎，，但有时候对于人员的流失仍然感到无能为力，我为的不是别的，我热爱我所在的团队，我感动于团队成员每一个人的付出和带来的欢乐。</p><p>说句直接点的话，金钱本身无法起到决定性作用，留在这里并努力着很大一部分原因是因为这个团队的存在。公司主力业务是人头外包，虽然也努力开拓其他业务，但明眼人都知道这种人力输出最难的是留住技术人才，最难的就是将技术沉淀，从而成为自己的技术积累以备用到自己的产品上来。我是一直梦想着公司有一天可以做自己的产品，公司能在某个行业上有一定的话语权，从而创造一定的价值，但现实告诉我我很年轻，公司虽然有进行很多尝试，但都收效甚微。不得不承认，当前这个情境之下想做活一个产品并非易事，因为所有的念想和计划最终都会碍于成本而最终放弃，甚至是压根不敢于开始。</p><p>前段时间公司上市，说真的我不是很理解这个点，融资的确重要，有人投资才会有更多的钱做更多的事情从而产生更多的价值，但是如何保证投资人的利益，如何保证股东的利益都成了必须面临的问题。员工技术储备不够，公司整体技术沉淀不够牢固，这都是面上的话，其实就是公司并没有办法留住人才，看着曾经一起奋斗的同事相继离职，我真觉得这是一种悲哀，感到一股悲凉。</p><p>我感觉在这段迷途上走了很久，从15年初开始，由于基本修完了大学的专业课程，通过老师找到这里，开始了长达三年的工作。这种迷茫感从我16年毕业开始涌现，女票想追求更高的学术造诣，不满于在饿了么ESRC做运营决定在母校保研读研，我也静下心来决定努力改变点什么，但自己的能力自己清楚，绵薄之力无以覆天，大部分人只是想要一份工作而已，能生活就足够了。慢慢的这种迷茫感越来越浓厚，也让自己开始安于现状。</p><p>现在，我从之前的公司离职了，说实话有些不舍，但更多的是对未来的憧憬，经过几年的磨练我在某些事情上更加处之泰然，也懂得了为人处事的一些道理，比起老生常谈的“你读读研究生其实更好”不再有所质疑，因为很多东西是学校里学不到的，海大教给了我很多，但是社会可以教给我更多。目前我仍然在不停地学习，虽然有的时候会被工作、生活等种种状况所打扰、搁置，但是我仍然在尽可能的坚持着，学习这件事情是万万不能放下的。</p><p>路还有很长，路要慢慢走，一步一个脚印，坚持做的事情要坚持下去。忙过了这一阵，我想应该可以静下心来沉淀沉淀，如果有可能的话，我想补偿一下过去的自己，也想弥补一下先前未做的事，虽然时间不能重来，但是我可以努力去完善现在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x80-迷途不知返&quot;&gt;&lt;a href=&quot;#0x80-迷途不知返&quot; class=&quot;headerlink&quot; title=&quot;0x80 迷途不知返&quot;&gt;&lt;/a&gt;0x80 迷途不知返&lt;/h3&gt;&lt;p&gt;转眼一看年都过去一个月了，这半个月来的生活真的是相当不容易。去年没有总结，但
      
    
    </summary>
    
    
      <category term="Ordinary" scheme="https://fioneragh.github.io/tags/Ordinary/"/>
    
  </entry>
  
  <entry>
    <title>使用btrfs-convert转换ext4</title>
    <link href="https://fioneragh.github.io/2018/02/06/%E4%BD%BF%E7%94%A8btrfs-convert%E8%BD%AC%E6%8D%A2ext4/"/>
    <id>https://fioneragh.github.io/2018/02/06/使用btrfs-convert转换ext4/</id>
    <published>2018-02-06T13:00:25.000Z</published>
    <updated>2019-01-16T04:46:38.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-btrfs"><a href="#0x81-btrfs" class="headerlink" title="0x81 btrfs"></a>0x81 btrfs</h3><p>前面提到APFS的时候,涉及到一个很棒的特性–COW(Copy On Write),即写时复制,它的工作原理不在这里展开,通俗的讲,就是复制或使用副本时不会真正的创建副本,而是藉由操作系统的支持,共享数据资源,而当有程序有写入需求时,此时不能再公用同一资源,因此要进行真正的复制.</p><p>其中High Sierra在Mac设备上默认启用的APFS自然支持这一特性,从而减少一些资源在使用时的占用空间,那Linux是否有文件系统支持这一特性呢?出于实验COW特性和做一些测试的目的,我找到了之前被诟病极不稳定的btrfs.</p><p>btrfs算是 比较年轻的文件系统,但算起它最开始进入kernel stage也有一段时间了,并且btrfs的维护者声称它目前已经足够稳定以投入生产使用甚至专门为SSD进行了优化,良好的trim支持让用户不必担心ext4”烧盘”的问题,虽然我在ext4下使用discard参数使用了很久也没出现很严重的性能问题或损坏,但我还是再次尝试了这一文件系统.</p><p>原则上讲,我们使用btrfs最好是从头开始,但是碍于自己在折腾了arch后实在是不想在重新安装并配置各种环境并且根挂载点是在单独的小分区上,我便决定直接转换ext4到btrfs,而转换时使用的工具就是btrfs-convert.</p><h3 id="0x82-btrfs-convert"><a href="#0x82-btrfs-convert" class="headerlink" title="0x82 btrfs-convert"></a>0x82 btrfs-convert</h3><p>btrfs-convert是一个转换工具,使用方式很简单,看它的<a href="https://btrfs.wiki.kernel.org/index.php/Manpage/btrfs-convert" target="_blank" rel="noopener">Manpage</a>,wiki里写到他可以转换ext2/3/4和reiserfs到btrfs.</p><p>转换工具使用就一句命令:<code>btrfs-convert /dev/sda2</code>,需要注意的是我们通常在live环境下执行,因为你无法转换一个已被挂载或正在使用的文件系统.以ext4为例,经过不确定时间的转换,原本的数据会以subvolume的形式保存,名字为ext2_saved.</p><a id="more"></a><h3 id="0x83-rollback"><a href="#0x83-rollback" class="headerlink" title="0x83 rollback"></a>0x83 rollback</h3><p>如果你后悔了,btrfs的快照功能也恰巧保证了回滚特性的支持,如上所说的ext2_saved子卷便是用于回滚的数据备份,因此如果我们想回滚,千万不能执行<code>btrfs balance</code>命令来平衡空间刷新metadata,否则回滚将会失败.</p><h3 id="0x84-grub-amp-boot"><a href="#0x84-grub-amp-boot" class="headerlink" title="0x84 grub &amp; boot"></a>0x84 grub &amp; boot</h3><p>在转换完文件系统之后,你一定会意识到GPT上的对应UUID已经发生了变化,而你如果用到了UUID,那这个变化将可能导致原本的操作系统引导失败,它们主要影响了3个地方:</p><ol><li><p>grub2 root=UUID mismatch</p><p> grub2-efi提供的grub2-mkconfig工具生成的grub.cfg里,root=UUID=XXX中的XXX是根分区原本的UUID,如果我们不对grub.cfg作相应的更改,必将导致引导出错.通常情况下我们不被推荐直接修改grub.cfg,我们可以通过chroot切换root环境重新生成grub.cfg.</p></li><li><p>initramdisk failed</p><p> 在安装内核的时候,由于很多部分(包括内核模块,不包含外挂模块)是immutable的,所以内核安装工具会构建缓存文件成ramdisk以供设备启动时快速加载和构建一个隔离环境,和macoOS的PrelinkedKernels(`/System/Library/PrelinkedKernels)类似.现在我们转换了文件系统,原本映射的ext4需要启用btrfs模块来保证正确挂载我们的根分区,因此我们需要mkinitrd工具重新生成ramdisk.</p><p> PS:我其实一开始没有执行这步,但是遇到btrfs没法使用的状况,查看mount参数发现根分区是ro的,经过查阅资料发现某些情况下遇到panic会导致btrfs从rw回落到ro以保护数据,而我mkinitrd重新生成ramdisk并更新grub2后便没在遇到这个问题.</p></li><li><p>fstab</p><p> 文件系统描述如果使用的是<code>/dev/</code>设备描述符则不需要修改,否则要修改对应的UUID.</p></li></ol><h3 id="0x85-后续工作"><a href="#0x85-后续工作" class="headerlink" title="0x85 后续工作"></a>0x85 后续工作</h3><p>如果你用的还算正常不打算回滚,那接下来就可以做些清理工作从而减少不必要的空间占用:</p><ul><li><p>fsck: 使用fsck.btrfs或其他检查工具排错败修正错误的元数据</p></li><li><p>ext2_saved: <code>btrfs subvolume delete /ext2_saved</code>,备份快照已经没有用了</p></li><li><p>defrag: <code>btrfs filesystem defrag -v -r -f -t 32M FILE_SYSTEM</code>,不是必须的,并且可能会带来问题,但是它可以让数据更加连续,尤其对机械硬盘来讲能提高吞吐,建议live环境下进行</p></li><li><p>balance: <code>btrfs balance start -m /mnt/btrfs</code>,平衡metadata空间,合并metadata group,释放不必要的空间浪费</p></li></ul><p>到这就差不多了,至于btrfs其他的优化对SSD来讲显得没那么重要,随着不断地使用它能更好地适应我们的操作系统,当然对于这一实验性文件系统,没理由不跟着kernel的更新来保证btrfs更好更快得工作.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-btrfs&quot;&gt;&lt;a href=&quot;#0x81-btrfs&quot; class=&quot;headerlink&quot; title=&quot;0x81 btrfs&quot;&gt;&lt;/a&gt;0x81 btrfs&lt;/h3&gt;&lt;p&gt;前面提到APFS的时候,涉及到一个很棒的特性–COW(Copy On Write),即写时复制,它的工作原理不在这里展开,通俗的讲,就是复制或使用副本时不会真正的创建副本,而是藉由操作系统的支持,共享数据资源,而当有程序有写入需求时,此时不能再公用同一资源,因此要进行真正的复制.&lt;/p&gt;
&lt;p&gt;其中High Sierra在Mac设备上默认启用的APFS自然支持这一特性,从而减少一些资源在使用时的占用空间,那Linux是否有文件系统支持这一特性呢?出于实验COW特性和做一些测试的目的,我找到了之前被诟病极不稳定的btrfs.&lt;/p&gt;
&lt;p&gt;btrfs算是 比较年轻的文件系统,但算起它最开始进入kernel stage也有一段时间了,并且btrfs的维护者声称它目前已经足够稳定以投入生产使用甚至专门为SSD进行了优化,良好的trim支持让用户不必担心ext4”烧盘”的问题,虽然我在ext4下使用discard参数使用了很久也没出现很严重的性能问题或损坏,但我还是再次尝试了这一文件系统.&lt;/p&gt;
&lt;p&gt;原则上讲,我们使用btrfs最好是从头开始,但是碍于自己在折腾了arch后实在是不想在重新安装并配置各种环境并且根挂载点是在单独的小分区上,我便决定直接转换ext4到btrfs,而转换时使用的工具就是btrfs-convert.&lt;/p&gt;
&lt;h3 id=&quot;0x82-btrfs-convert&quot;&gt;&lt;a href=&quot;#0x82-btrfs-convert&quot; class=&quot;headerlink&quot; title=&quot;0x82 btrfs-convert&quot;&gt;&lt;/a&gt;0x82 btrfs-convert&lt;/h3&gt;&lt;p&gt;btrfs-convert是一个转换工具,使用方式很简单,看它的&lt;a href=&quot;https://btrfs.wiki.kernel.org/index.php/Manpage/btrfs-convert&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Manpage&lt;/a&gt;,wiki里写到他可以转换ext2/3/4和reiserfs到btrfs.&lt;/p&gt;
&lt;p&gt;转换工具使用就一句命令:&lt;code&gt;btrfs-convert /dev/sda2&lt;/code&gt;,需要注意的是我们通常在live环境下执行,因为你无法转换一个已被挂载或正在使用的文件系统.以ext4为例,经过不确定时间的转换,原本的数据会以subvolume的形式保存,名字为ext2_saved.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://fioneragh.github.io/tags/Linux/"/>
    
      <category term="btrfs" scheme="https://fioneragh.github.io/tags/btrfs/"/>
    
  </entry>
  
  <entry>
    <title>解密FileVault2加密的分区</title>
    <link href="https://fioneragh.github.io/2018/02/05/%E8%A7%A3%E5%AF%86FileVault2%E5%8A%A0%E5%AF%86%E7%9A%84%E5%88%86%E5%8C%BA/"/>
    <id>https://fioneragh.github.io/2018/02/05/解密FileVault2加密的分区/</id>
    <published>2018-02-05T11:41:05.000Z</published>
    <updated>2019-01-16T04:46:38.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-FileVault"><a href="#0x81-FileVault" class="headerlink" title="0x81 FileVault"></a>0x81 FileVault</h3><p>像Windows的BitLocker一样,Apple也为macOS(最早应该是OSX Lion开始支持)提供了全盘加密的支持,它就是FileVault,目前该项技术名字叫做FileVault2.当你第一次进入macOS的配置向导,或是从某一次重要的更新重新配置你的mac时,FileVault2会有很大的几率露脸,询问你是否要启用加密特性来保护你的个人数据安全.</p><p>当然,所有的安全特性包括磁盘加密都会带来性能损失,因为从安全的角度上讲,你的数据要保证安全加密是必须的,而当你要使用这些数据时,就需要通过验证并解密才能成为程序可读的数据.不过话说回来,操作系统会尽可能正确的权衡性能与安全的比重,尤其是Apple整个新产品线都采用nvme的固态硬盘以及使用专门的硬件模块来保证性能.但是第三方SSD就不见得能更好的配合这些为原生苹果硬件提供的特性了,比如臭名昭著的黑苹果,几乎大部分硬件都是fake来得.</p><h3 id="0x82-APFS"><a href="#0x82-APFS" class="headerlink" title="0x82 APFS"></a>0x82 APFS</h3><p>APFS,全程APple FileSystem,译作苹果文件系统,很多人坚持它由ZFS发展而来,但是这不重要.APFS支持COW,对SSD友好,支持SSD的Trim特性以增高IO吞吐,更重要的是它支持逻辑卷管理.正因为APFS支持这些新特性,Apple终于决定换掉用了十几二十年的HFS(+J),从iOS,tvOS,watchOS到macOS都采用了这一文件系统.</p><p>APFS的出现对黑苹果用户来讲可不见得是好事,High Sierra默认已经将APFS作为默认的文件系统,在升级或安装若检测到你的硬盘是固态硬盘,将会在升级或安装过程中进行APFS的转换,要注意这个转换是不可逆的.纵然如此,我们仍可以干涉macOS的升级进程,既然升级过程是从HFS+转换到APFS的,说明这个过程是使用标志位控制的,在这个过程中有一个转换操作.</p><p>仔细研究过macOS升级过程的小伙伴应该都了解用于安装的app文件里有个非常庞大的dmg文件,dmg文件我们都了解就是磁盘映像文件,和iso/img文件类似,而dmg文件内是一些pkg安装文件和plist或xml配置文件,安装过程首先就是释放这些安装程序和配置文件,我们只需要把配置文件中的ConvertToApfs设置为false就可以阻止转换过程.</p><p>为什么要阻止转换成APFS呢,一个是前面说的SSD兼容问题,一个是黑苹果导致的一些乱七八糟的问题,比如刚开始APFS出现导致Clover识别不到APFS分区,后来是Clover通过实现加载macOS安装镜像的apfs.efi来读取APFS,但是APFS在hackintosh上的问题远不止这些.</p><a id="more"></a><h3 id="0x83-CoreStorage"><a href="#0x83-CoreStorage" class="headerlink" title="0x83 CoreStorage"></a>0x83 CoreStorage</h3><p>前面说了APFS这么多和FileVault有什么关系呢?</p><p>这里不得不说说CoreStorage这一让人又爱又恨的技术,最初被cs坑到是安装10.11时遭遇的4主分区限制,由于个人需要分区多分出了两个,由于原本的分区表存在EFI/RecoveryHD分区,因此加上MachintoshHD和额外的两个分区正好超出了4个分区,导致安装时包报CoreStorage错误,原来是安装程序主动转换HFS分区为能进行逻辑卷管理的CoreStorage,然后在CoreStorage中进行灵活的分卷管理,而这灵活的分卷管理就是相对让人爱的地方,和基础版的LVM用起来感觉差不多.第二个坑是黑苹果升级的坑,CoreStorage下的分区在进行Software Update之后无法向分区写入安装更新引导信息从而导致更新失败,害我那天一直以为是升级没接电源导致的.</p><p>那最新的APFS是否也支持逻辑卷管理呢?苹果不会开倒车,APFS天生支持Container并且APFS Volume是建立在APFS Container之中.从Fushion Drive的支持来看,逻辑卷不是某一文件系统的专利,它是一种更为上层的控制逻辑,或者可以认为它是特殊的软RAID,而Fushion Drive就可以视作软RAID,它能让两块硬盘看起来像一块硬盘甚至一个分区在工作.</p><p>终于该说FileVault了,这里其实源于我一个同事的黑苹果升级后误选了启用FileVault2加密,乖乖,电脑卡了一下午最后不得已才重启发现Clover居然读不到macOS分区,Clover能识别HFS和APFS,现在读不出来只有一个可能–分区被加密了,通过查阅资料发现FileVault Preboot(Preboot是APFS Container的一项特殊技术,有点类似我之前说的更新需要使用的更新引导信息的载体,不过之前是在一个分区上,而APFS将他们放到一个卷上)也许可以进入,然后输入密码进入设置进行FileVault解密,但是悲剧的是进去之后黑苹果的键鼠都是失效的,干瞪眼= =</p><h3 id="0x84-强大的diskutil"><a href="#0x84-强大的diskutil" class="headerlink" title="0x84 强大的diskutil"></a>0x84 强大的diskutil</h3><p>其实系统遇到问题,我们最直接的想法就是进入恢复模式,macOS的Recovery是我认为恢复环境里做的比较好的,虽然它通常只用来在线恢复系统= =,其实它还提供了磁盘工具可以进行磁盘检查或者删掉多余的分区,但是这个磁盘工具也是被编码猴子们一直诟病的存在,它呈现的功能实在太少了,也许对于普通用户来讲这足够且合理.所幸Recovery提供了终端,我们有了diskutil和一些列命令行工具,就能进行更多的修复工作.</p><p>接下来是解密的过程,过程很简单,但是等了好久= =,毕竟要等数据全部解密然后自然而然FileVault会自动关闭.</p><ol><li><p>获取apfs container 信息</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">fionera@Fioneras-MacBook-Air:~|⇒  diskutil apfs list</span><br><span class="line">APFS Container (1 found)</span><br><span class="line">|</span><br><span class="line">+-- Container disk2 9CC08098-8466-435A-ABAD-722607D6E6ED</span><br><span class="line">    ====================================================</span><br><span class="line">    APFS Container Reference:     disk2</span><br><span class="line">    Capacity Ceiling (Size):      89768812544 B (89.8 GB)</span><br><span class="line">    Capacity In Use By Volumes:   47518322688 B (47.5 GB) (52.9% used)</span><br><span class="line">    Capacity Not Allocated:       42250489856 B (42.3 GB) (47.1% free)</span><br><span class="line">    Container Shrink Limit:       58255740928 B (58.3 GB)</span><br><span class="line">    |</span><br><span class="line">    +-&lt; Physical Store disk1s2 D559D0FF-154F-4D2E-A5A2-8FC9F23F97B8</span><br><span class="line">    |   -----------------------------------------------------------</span><br><span class="line">    |   APFS Physical Store Disk:   disk1s2</span><br><span class="line">    |   Size:                       89768812544 B (89.8 GB)</span><br><span class="line">    |</span><br><span class="line">    +-&gt; Volume disk2s1 0070DBC0-5E43-3CB5-9E7F-87863226444D</span><br><span class="line">    |   ---------------------------------------------------</span><br><span class="line">    |   APFS Volume Disk (Role):   disk2s1 (No specific role)</span><br><span class="line">    |   Name:                      M10134 (Case-insensitive)</span><br><span class="line">    |   Mount Point:               /</span><br><span class="line">    |   Capacity Consumed:         46854705152 B (46.9 GB)</span><br><span class="line">    |   FileVault:                 No</span><br><span class="line">    |</span><br><span class="line">    +-&gt; Volume disk2s2 9B3B032E-1B8D-4F16-AC1E-BDCF50C0B15B</span><br><span class="line">    |   ---------------------------------------------------</span><br><span class="line">    |   APFS Volume Disk (Role):   disk2s2 (VM)</span><br><span class="line">    |   Name:                      VM (Case-insensitive)</span><br><span class="line">    |   Mount Point:               /private/var/vm</span><br><span class="line">    |   Capacity Consumed:         20480 B (20.5 KB)</span><br><span class="line">    |   FileVault:                 No</span><br><span class="line">    |</span><br><span class="line">    +-&gt; Volume disk2s3 D89A01D6-70B7-4625-97AB-8876F36F188C</span><br><span class="line">    |   ---------------------------------------------------</span><br><span class="line">    |   APFS Volume Disk (Role):   disk2s3 (Preboot)</span><br><span class="line">    |   Name:                      Preboot (Case-insensitive)</span><br><span class="line">    |   Mount Point:               Not Mounted</span><br><span class="line">    |   Capacity Consumed:         21127168 B (21.1 MB)</span><br><span class="line">    |   FileVault:                 No</span><br><span class="line">    |</span><br><span class="line">    +-&gt; Volume disk2s4 ED0CDC7F-A5EA-42D8-A25E-0FF720CC1A02</span><br><span class="line">        ---------------------------------------------------</span><br><span class="line">        APFS Volume Disk (Role):   disk2s4 (Recovery)</span><br><span class="line">        Name:                      Recovery (Case-insensitive)</span><br><span class="line">        Mount Point:               Not Mounted</span><br><span class="line">        Capacity Consumed:         518991872 B (519.0 MB)</span><br><span class="line">        FileVault:                 No</span><br></pre></td></tr></table></figure><p> 输出结果类似上图,不得不说macOS的diskutil对apfs的信息输出还是比较全面的,我们也可以明确的看到FileVault的开启情况.</p></li><li><p>获取APFS Volume上的CryptoUser</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fionera@Fioneras-MacBook-Air:~|⇒  diskutil apfs listUsers /</span><br><span class="line">Cryptographic user <span class="keyword">for</span> disk2s1 (1 found)</span><br><span class="line">|</span><br><span class="line">+-- 1FA5C6EC-29DF-4132-9B2A-AC61886ADACD</span><br><span class="line">    Type: Local Open Directory User</span><br></pre></td></tr></table></figure><p> 其中那段UUID就是用于解密FileVault的用户标识,这里只有一个LODU,对于加密过的还会有一个iCloud账户,当然如果你手动添加过,也会一一列举出来.</p></li><li><p>decryptVolume</p><p> 没什么好说的,解密分卷关闭FileVault,执行之后可以再第一步中看到进度,等到解密完成一切就可以恢复正常.</p><p> 但是注意这里有一个坑,就是我第二步讲到的用户标识符UUID,如果我在执行<code>diskutil apfs decryptVolume &lt;apfsVolumeDisk&gt;</code>不添加<code>--user</code>参数,工具将默认使用<code>--user disk</code>也就是分区标识符作为用户标识符.那鉴权是一定会失败的,因此正确的命令应该是至少类似这样<code>diskutil apfs decryptVolume disk2s1 --user 1FA5C6EC-29DF-4132-9B2A-AC61886ADACD</code>,等待执行完成,就可以在Clover中看到久违的APFS分区.</p></li></ol><p>不得不说奋斗在黑苹果一线的rah等大牛就是在和苹果的开发人员作斗争,而折腾黑苹果也变成我了解macOS工作机制和系统特性的重要手段,由此出发而接触到APCI汇编,UEFI环境知识都不是我在日常开发工作中所能学习和了解的,在这些盲区学一些用不到的知识不一定没用,或许他们可以拓宽我们的思维,更透彻的了解他们的工作机理.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-FileVault&quot;&gt;&lt;a href=&quot;#0x81-FileVault&quot; class=&quot;headerlink&quot; title=&quot;0x81 FileVault&quot;&gt;&lt;/a&gt;0x81 FileVault&lt;/h3&gt;&lt;p&gt;像Windows的BitLocker一样,Apple也为macOS(最早应该是OSX Lion开始支持)提供了全盘加密的支持,它就是FileVault,目前该项技术名字叫做FileVault2.当你第一次进入macOS的配置向导,或是从某一次重要的更新重新配置你的mac时,FileVault2会有很大的几率露脸,询问你是否要启用加密特性来保护你的个人数据安全.&lt;/p&gt;
&lt;p&gt;当然,所有的安全特性包括磁盘加密都会带来性能损失,因为从安全的角度上讲,你的数据要保证安全加密是必须的,而当你要使用这些数据时,就需要通过验证并解密才能成为程序可读的数据.不过话说回来,操作系统会尽可能正确的权衡性能与安全的比重,尤其是Apple整个新产品线都采用nvme的固态硬盘以及使用专门的硬件模块来保证性能.但是第三方SSD就不见得能更好的配合这些为原生苹果硬件提供的特性了,比如臭名昭著的黑苹果,几乎大部分硬件都是fake来得.&lt;/p&gt;
&lt;h3 id=&quot;0x82-APFS&quot;&gt;&lt;a href=&quot;#0x82-APFS&quot; class=&quot;headerlink&quot; title=&quot;0x82 APFS&quot;&gt;&lt;/a&gt;0x82 APFS&lt;/h3&gt;&lt;p&gt;APFS,全程APple FileSystem,译作苹果文件系统,很多人坚持它由ZFS发展而来,但是这不重要.APFS支持COW,对SSD友好,支持SSD的Trim特性以增高IO吞吐,更重要的是它支持逻辑卷管理.正因为APFS支持这些新特性,Apple终于决定换掉用了十几二十年的HFS(+J),从iOS,tvOS,watchOS到macOS都采用了这一文件系统.&lt;/p&gt;
&lt;p&gt;APFS的出现对黑苹果用户来讲可不见得是好事,High Sierra默认已经将APFS作为默认的文件系统,在升级或安装若检测到你的硬盘是固态硬盘,将会在升级或安装过程中进行APFS的转换,要注意这个转换是不可逆的.纵然如此,我们仍可以干涉macOS的升级进程,既然升级过程是从HFS+转换到APFS的,说明这个过程是使用标志位控制的,在这个过程中有一个转换操作.&lt;/p&gt;
&lt;p&gt;仔细研究过macOS升级过程的小伙伴应该都了解用于安装的app文件里有个非常庞大的dmg文件,dmg文件我们都了解就是磁盘映像文件,和iso/img文件类似,而dmg文件内是一些pkg安装文件和plist或xml配置文件,安装过程首先就是释放这些安装程序和配置文件,我们只需要把配置文件中的ConvertToApfs设置为false就可以阻止转换过程.&lt;/p&gt;
&lt;p&gt;为什么要阻止转换成APFS呢,一个是前面说的SSD兼容问题,一个是黑苹果导致的一些乱七八糟的问题,比如刚开始APFS出现导致Clover识别不到APFS分区,后来是Clover通过实现加载macOS安装镜像的apfs.efi来读取APFS,但是APFS在hackintosh上的问题远不止这些.&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="https://fioneragh.github.io/tags/macOS/"/>
    
      <category term="FileVault" scheme="https://fioneragh.github.io/tags/FileVault/"/>
    
  </entry>
  
  <entry>
    <title>获取macOS的DeveloperBeta更新</title>
    <link href="https://fioneragh.github.io/2018/01/31/%E8%8E%B7%E5%8F%96macOS%E7%9A%84DeveloperBeta%E6%9B%B4%E6%96%B0/"/>
    <id>https://fioneragh.github.io/2018/01/31/获取macOS的DeveloperBeta更新/</id>
    <published>2018-01-31T10:32:34.000Z</published>
    <updated>2019-01-16T04:46:38.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-常规的获取更新方式"><a href="#0x81-常规的获取更新方式" class="headerlink" title="0x81 常规的获取更新方式"></a>0x81 常规的获取更新方式</h3><p>按道理来讲,我们如果想获得beta更新,只要注册AppleId为Developer账号就可以了,这样我们便可以获取beta更新工具从而配置我们的电脑为接收beta更新,即可下载并更新.但是Apple得开发者验证并不是随便就能申请的,他需要我们拥有可付费的应用或有接收支付的账户信息才能享受完整的开发者功能支持,而实际上成为一个真正的Apple开发者的年费也是不菲的.我作为一个称职的国内Android开发者,平时使用XCode也就是看看iOS应用源码或者是构建一些macOS应用及扩展.</p><p>受限于开发者账号的不完整性,我们没办法正常接收beta更新,那我们就没办法了么?其实原本的beta更新和Google释出的Android开发者镜像一样,是用于给开发者提前做应用适配的,后来为了让普通用户也能参与到测试当中来,Apple开启了PublicBeta众测计划,和Microsoft的Insider一样,每一个参与的用户都可以为系统的问题提交反馈.</p><p>我们从Apple开发者官网下载<code>macOSHighSierraPublicBetaAccessUtility</code>,运行工具同意协议输入密码后便可以加入PublicBeta,之后我们便可以在AppStore检查到beta更新.</p><h3 id="0x82-AccessUtility实际做的事情"><a href="#0x82-AccessUtility实际做的事情" class="headerlink" title="0x82 AccessUtility实际做的事情"></a>0x82 AccessUtility实际做的事情</h3><p>具有开发精神的我们肯定会思考,这个工具到底做了什么从而我们的macOS可以接受beta更新,并且一旦我们可以接收更新,在AppStore的偏好设置里便多出了不接收更新的选项,此时若我们取消接收,它实际上做了什么.</p><p>首先,安装过的pkg文件会释放bom文件到系统目录,Apple自家的通常在<code>/S/L/Receipts</code>目录下,第三方通常在<code>/var/db/receipts</code><br>目录下,其中完整的安装历史在<code>/Library/Receipts/InstallHistory.plist</code>文件当中,其中记录了安装时间,pkg包名以及安装方式等.</p><p>对于bom文件,我们可以使用<code>lsbom</code>命令直接查看,当然我们也可以不在意bom文件的具体位置,直接使用<code>pkgutil --files ${PKG_NAME}</code>来查看pkg文件到底创建了那些文件(Payload中有那些文件),通过分析结果我们不难发现其实pkg文件只释放了一个lpdf文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Library</span><br><span class="line">Library/Documentation</span><br><span class="line">Library/Documentation/Beta License.lpdf</span><br></pre></td></tr></table></figure><p>lpdf是一种特殊的bundle,和app文件类似,里面存放了一系列签名配置信息,当然也有我们熟悉的<code>Library/Documentation/Beta License.lpdf/Contents/Resources/zh_CN.lproj/Beta License.pdf</code>普通pdf文件.</p><p>既然如此,那也就是说明pkg安装并不是释放了一个特殊的配置文件来实现接收beta更新这件事情,只有可能是安装脚本(postScript)了,关于pkg文件结构我们后面在分析.</p><a id="more"></a><h3 id="0x83-seedutil-控制更新enroll"><a href="#0x83-seedutil-控制更新enroll" class="headerlink" title="0x83 seedutil 控制更新enroll"></a>0x83 seedutil 控制更新enroll</h3><p>其实Apple提供了Seeding框架来干预macOS的更新,而pkg文件其实也就是执行了一段seedutil脚本,pkg的主要作用在于让用户阅读并同意软件协议而已,而偏好设置里的取消更新也是使用seedutil取消了更新的接收.</p><p>Seeding.framework 提供了seedutil工具来管理beta更新的接收,seedutil的位置:<code>/System/Library/PrivateFrameworks/Seeding.framework/Versions/A/Resources/seedutil</code>,Apple并没有开放链接在<code>/usr/bin</code>下并且该工具执行需要root权限,我们可以使用sudo来使用这个工具.</p><p>我们首先来看一下,在安装AccessUtility之后的seed状态是什么:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">⇒  sudo /System/Library/PrivateFrameworks/Seeding.framework/Versions/A/Resources/seedutil current</span><br><span class="line">Password:</span><br><span class="line">Currently enrolled <span class="keyword">in</span>: PublicSeed</span><br><span class="line"></span><br><span class="line">Program: 3</span><br><span class="line">Build is seed: YES</span><br><span class="line">CatalogURL: https://swscan.apple.com/content/catalogs/others/index-10.13seed-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog.gz</span><br><span class="line">NSShowFeedbackMenu: NO</span><br><span class="line">DisableSeedOptOut: NO</span><br></pre></td></tr></table></figure><p><code>current</code>参数可以显示当前seed,我们可以看到<code>Currently enrolled in: PublicSeed</code>说明我们在PublicBeta上,然后使用<code>enroll</code>参数我们可以切换到DeveloperSeed:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">⇒  sudo /System/Library/PrivateFrameworks/Seeding.framework/Versions/A/Resources/seedutil enroll DeveloperSeed</span><br><span class="line">Enrolling...</span><br><span class="line"></span><br><span class="line">Program: 2</span><br><span class="line">Build is seed: YES</span><br><span class="line">CatalogURL: https://swscan.apple.com/content/catalogs/others/index-10.13seed-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog.gz</span><br><span class="line">NSShowFeedbackMenu: NO</span><br><span class="line">DisableSeedOptOut: NO</span><br></pre></td></tr></table></figure><p>这样,我们便可以接受DeveloperBeta更新,它往往比PublicBeta更早释出,当然,我之前虽然设置的是PublicBeta,但是安装的更新都是DeveloperBeta= =.</p><p>当然,seedutil还提供了<code>unenroll</code>参数供我们退出seed,他的作用和在AppStore的偏好设置选择取消是一样的.还有一个<code>fixup</code>参数可以用来修复角色,如果你接收不到beta更新的时候可以试试.</p><p>所以,如果你能下载到DeveloperBetaAccessUtility的话,你也可以直接pkg安装,他们的效果是一样的,但对于我这种登录开发者网站只能看到下载XCode的人(也有可能是我操作方式不对只能下载到PublicBeta,不过我原本一直不能登录iOS的Feedback应用,在我安装了DeveloperBeta后居然能登录了),用这种方式也能方便的接收更新,其实是手痒一定要试试macOS 10.13.4 的32位应用限制,也许只有苹果有推动力去做32位淘汰这件事情了,毕竟iOS算是一次成功的尝试.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-常规的获取更新方式&quot;&gt;&lt;a href=&quot;#0x81-常规的获取更新方式&quot; class=&quot;headerlink&quot; title=&quot;0x81 常规的获取更新方式&quot;&gt;&lt;/a&gt;0x81 常规的获取更新方式&lt;/h3&gt;&lt;p&gt;按道理来讲,我们如果想获得beta更新,只要注册AppleId为Developer账号就可以了,这样我们便可以获取beta更新工具从而配置我们的电脑为接收beta更新,即可下载并更新.但是Apple得开发者验证并不是随便就能申请的,他需要我们拥有可付费的应用或有接收支付的账户信息才能享受完整的开发者功能支持,而实际上成为一个真正的Apple开发者的年费也是不菲的.我作为一个称职的国内Android开发者,平时使用XCode也就是看看iOS应用源码或者是构建一些macOS应用及扩展.&lt;/p&gt;
&lt;p&gt;受限于开发者账号的不完整性,我们没办法正常接收beta更新,那我们就没办法了么?其实原本的beta更新和Google释出的Android开发者镜像一样,是用于给开发者提前做应用适配的,后来为了让普通用户也能参与到测试当中来,Apple开启了PublicBeta众测计划,和Microsoft的Insider一样,每一个参与的用户都可以为系统的问题提交反馈.&lt;/p&gt;
&lt;p&gt;我们从Apple开发者官网下载&lt;code&gt;macOSHighSierraPublicBetaAccessUtility&lt;/code&gt;,运行工具同意协议输入密码后便可以加入PublicBeta,之后我们便可以在AppStore检查到beta更新.&lt;/p&gt;
&lt;h3 id=&quot;0x82-AccessUtility实际做的事情&quot;&gt;&lt;a href=&quot;#0x82-AccessUtility实际做的事情&quot; class=&quot;headerlink&quot; title=&quot;0x82 AccessUtility实际做的事情&quot;&gt;&lt;/a&gt;0x82 AccessUtility实际做的事情&lt;/h3&gt;&lt;p&gt;具有开发精神的我们肯定会思考,这个工具到底做了什么从而我们的macOS可以接受beta更新,并且一旦我们可以接收更新,在AppStore的偏好设置里便多出了不接收更新的选项,此时若我们取消接收,它实际上做了什么.&lt;/p&gt;
&lt;p&gt;首先,安装过的pkg文件会释放bom文件到系统目录,Apple自家的通常在&lt;code&gt;/S/L/Receipts&lt;/code&gt;目录下,第三方通常在&lt;code&gt;/var/db/receipts&lt;/code&gt;&lt;br&gt;目录下,其中完整的安装历史在&lt;code&gt;/Library/Receipts/InstallHistory.plist&lt;/code&gt;文件当中,其中记录了安装时间,pkg包名以及安装方式等.&lt;/p&gt;
&lt;p&gt;对于bom文件,我们可以使用&lt;code&gt;lsbom&lt;/code&gt;命令直接查看,当然我们也可以不在意bom文件的具体位置,直接使用&lt;code&gt;pkgutil --files ${PKG_NAME}&lt;/code&gt;来查看pkg文件到底创建了那些文件(Payload中有那些文件),通过分析结果我们不难发现其实pkg文件只释放了一个lpdf文件:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Library&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Library/Documentation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Library/Documentation/Beta License.lpdf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;lpdf是一种特殊的bundle,和app文件类似,里面存放了一系列签名配置信息,当然也有我们熟悉的&lt;code&gt;Library/Documentation/Beta License.lpdf/Contents/Resources/zh_CN.lproj/Beta License.pdf&lt;/code&gt;普通pdf文件.&lt;/p&gt;
&lt;p&gt;既然如此,那也就是说明pkg安装并不是释放了一个特殊的配置文件来实现接收beta更新这件事情,只有可能是安装脚本(postScript)了,关于pkg文件结构我们后面在分析.&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="https://fioneragh.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>使用Vuex的namespace管理状态</title>
    <link href="https://fioneragh.github.io/2018/01/25/%E4%BD%BF%E7%94%A8Vuex%E7%9A%84namespace%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81/"/>
    <id>https://fioneragh.github.io/2018/01/25/使用Vuex的namespace管理状态/</id>
    <published>2018-01-25T12:37:29.000Z</published>
    <updated>2019-01-16T04:46:38.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-Vue组件通信"><a href="#0x81-Vue组件通信" class="headerlink" title="0x81 Vue组件通信"></a>0x81 Vue组件通信</h3><p>Vue在升级到2.x之后,仍然提供了比较灵活的组件间通信机制,父向子组件的prop[broadcast],子向父组件的emit冒泡,但是如果我想子组件与子组件通信甚至是跨多组件通信,用这种关联的机制虽然能够做到,但是却极为麻烦.在这种情况下,我们可以使用Vue官方推荐的状态管理工具Vuex来统一控制整个SPA的状态.</p><h3 id="0x82-Store"><a href="#0x82-Store" class="headerlink" title="0x82 Store"></a>0x82 Store</h3><p>Vuex和Redux一样,是针对js的一种全局状态管理,他们都扮演状态控制中心的角色.Vuex使用action作为状态通知的唯一触发者,mutation作为状态的接受者,state则存储了我们需要管理的SPA的状态,通常情况下我们也会使用types来规约action.</p><p>在平时的的开发过程中,为了保证各模块或各功能的相对低耦合,我们会把有关的actions/mutations/state组合起来作为一个store,供给vuex进行统一管理.</p><a id="more"></a><h3 id="0x83-namespace"><a href="#0x83-namespace" class="headerlink" title="0x83 namespace"></a>0x83 namespace</h3><p>在最开始的时候,由于自己编写的小项目内容较少,大部分state都是全局状态下的state,我在需要他们的地方进行获取和修改.随着项目越来越大,我便使用某种prefix作为功能模块的划分,通过js代码编写上的层次来区分各个模块,但是这样随着项目打到一定程度以及命名越来越长,这种方式越来越不符合规范,在当时那段时间我便花时间把整个Vuex部分重构,使用官方推荐的namespace来管理各模块的状态.</p><p>namespace的使用很简单,他只是一个属性,通常情况下我们的store会这样声明:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    i18n: vuexI18n.store,</span><br><span class="line">    customStore: CustomStore</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面声明的store包含了两个部分:全局状态和模块状态,其中state/mutations/actions是全局store,而CustomStore便是我们的模块store,如果我们不添加namespace,那modules中的store便会被合并,这不是我们想要的,我们在CustomStore中添加namespace:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/store/customStore.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// here for using namespace</span></span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    tabIndex: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    updateTabIndex(state, payload) &#123;</span><br><span class="line">      state.tabIndex = payload.tabIndex</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    updateTabIndex(&#123; commit &#125;, tabIndex) &#123;</span><br><span class="line">      commit(<span class="string">'updateTabIndex'</span>, &#123; tabIndex &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的customStore便会被加上命名空间,在使用时更加灵活自由.</p><h3 id="0x84-使用namespace获取actions-state"><a href="#0x84-使用namespace获取actions-state" class="headerlink" title="0x84 使用namespace获取actions/state"></a>0x84 使用namespace获取actions/state</h3><p>全局状态下的state控制我们通常使用mapActions/mapState(mapGetters)来获取修改状态的方法和修改后的状态数据(修改后的状态数据会自动observe从而触发computed计算属性的效果),那如果我们加上了namespace之后该如何使用?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// need be replaced to mapGetters, now delegate</span></span><br><span class="line">  ...mapState(<span class="string">'customStore'</span>, &#123;</span><br><span class="line">    _tabIndex: <span class="function"><span class="params">state</span> =&gt;</span> state.tabIndex,</span><br><span class="line">    xxx: <span class="function"><span class="params">state</span> =&gt;</span> state.xxx</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(<span class="string">'customStore'</span>, [<span class="string">'updateTabIndex'</span>, <span class="string">'xxx'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方式获取到的触发action方法和获取的状态就是在customStore下的,从而满足我们的需要.</p><p>当然,Vuex其实灵活的用法还挺多的,官方文档一如Vue.js一样完整易懂,得益于尤大大对中文文档的完善,基本上看完文档那Vuex的用法都就明了了.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-Vue组件通信&quot;&gt;&lt;a href=&quot;#0x81-Vue组件通信&quot; class=&quot;headerlink&quot; title=&quot;0x81 Vue组件通信&quot;&gt;&lt;/a&gt;0x81 Vue组件通信&lt;/h3&gt;&lt;p&gt;Vue在升级到2.x之后,仍然提供了比较灵活的组件间通信机制,父向子组件的prop[broadcast],子向父组件的emit冒泡,但是如果我想子组件与子组件通信甚至是跨多组件通信,用这种关联的机制虽然能够做到,但是却极为麻烦.在这种情况下,我们可以使用Vue官方推荐的状态管理工具Vuex来统一控制整个SPA的状态.&lt;/p&gt;
&lt;h3 id=&quot;0x82-Store&quot;&gt;&lt;a href=&quot;#0x82-Store&quot; class=&quot;headerlink&quot; title=&quot;0x82 Store&quot;&gt;&lt;/a&gt;0x82 Store&lt;/h3&gt;&lt;p&gt;Vuex和Redux一样,是针对js的一种全局状态管理,他们都扮演状态控制中心的角色.Vuex使用action作为状态通知的唯一触发者,mutation作为状态的接受者,state则存储了我们需要管理的SPA的状态,通常情况下我们也会使用types来规约action.&lt;/p&gt;
&lt;p&gt;在平时的的开发过程中,为了保证各模块或各功能的相对低耦合,我们会把有关的actions/mutations/state组合起来作为一个store,供给vuex进行统一管理.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://fioneragh.github.io/tags/Vue/"/>
    
      <category term="Vuex" scheme="https://fioneragh.github.io/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>用efibootmgr修改UEFI引导项</title>
    <link href="https://fioneragh.github.io/2017/12/26/%E7%94%A8efibootmgr%E4%BF%AE%E6%94%B9UEFI%E5%BC%95%E5%AF%BC%E9%A1%B9/"/>
    <id>https://fioneragh.github.io/2017/12/26/用efibootmgr修改UEFI引导项/</id>
    <published>2017-12-26T02:18:49.000Z</published>
    <updated>2019-01-16T04:46:38.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-efibootmgr的作用"><a href="#0x81-efibootmgr的作用" class="headerlink" title="0x81 efibootmgr的作用"></a>0x81 efibootmgr的作用</h3><p>相比校传统的MBR引导方式,Intel坚持的UEFI则更加可控,灵活和自由.UEFI又叫通用嵌入式固件接口,近几年的主板BIOS通常都实现了UEFI支持,可以运行EFI程序.早期出于好奇,我试用了非常多的Linux发行版,而这些版本由于采用传统的MBR引导方式安装,基本每一次fresh install都能清理掉就的引导记录.在某次偶然的机会将硬盘转换为了GPT分区表后,便不能使用传统的安装方式,借助grub2-efi的支持,在GPT分区上使用EFI分区内的efi引导程序进行系统的引导.</p><p>在使用EFI后,大约过了一年半的时间,期间因为各种问题也切换过发行版,后来在一次清理中发现了好几个残留的UEFI引导项,到这时候才意识到之前的选项都没有删掉,于是便找到了efibootmgr这个工具,它可以管理UEFI的引导项.</p><p>efibootmgr支持引导项的查看,添加,修改和删除,功能比较强大,但是操作时尤其是删除操作要极为慎重,不小心删掉的硬件引导(比如网卡引导)可不太容易恢复.</p><h3 id="0x82-使用efibootmgr修改EFI"><a href="#0x82-使用efibootmgr修改EFI" class="headerlink" title="0x82 使用efibootmgr修改EFI"></a>0x82 使用efibootmgr修改EFI</h3><ol><li><p>查看引导项</p><p> 使用efibootmgr可以直接查看当前固件里的引导项:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fionera@fionera:~|⇒  efibootmgr</span><br><span class="line">BootCurrent: 0003</span><br><span class="line">Timeout: 2 seconds</span><br><span class="line">BootOrder: 0003,0008,0009,0005</span><br><span class="line">Boot0003* fedora</span><br><span class="line">Boot0005  Windows Boot Manager</span><br><span class="line">Boot0008* UEFI: IP4 Realtek PCIe FE Family Controller</span><br><span class="line">Boot0009* UEFI: IP6 Realtek PCIe FE Family Controlle</span><br></pre></td></tr></table></figure></li><li><p>删除引导项</p><p> efibootmgr提供删除参数-B(–delete-bootnum),该参数后接要删除的项编号,使用该指令可以删除Windows Boot Manager:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efibootmgr -B -b 0005 // 0005 为bootnum</span><br></pre></td></tr></table></figure></li><li><p>新增引导项</p><p> 如果要新增一个引导项,我们需要进行多个参数的组合,包括名称和EFI路径等,下面的指令可以为<code>p{EFI}/EFI/CLOVER/CLOVERX64.efi</code>添加一个引导项:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efibootmgr -c -w -L &quot;Clover&quot; -d /dev/sda -p 1 -l \\EFI\\CLOVER\\CLOVERX64.efi</span><br></pre></td></tr></table></figure><p> 上述指令中各参数的意义:</p><ul><li>[-c] 创建一条引导</li><li>[-w] 这一次创建会写入EFI引导信息</li><li>[-L] 引导项的Label</li><li>[-d] 指定使用的物理硬盘描述符</li><li>[-p] 分区号,从1开始默认为1</li><li>[-l] EFI文件位置,’/‘位置代表前面指定的根分区,由于通用性考虑,命令使用’\‘代表文件路径分隔符</li></ul></li><li><p>编辑引导项</p><p> 在未知时创造是困难的,在已知时修改是可控的,与删除类似,efibootmgr提供了很多参数来修改引导项或整个引导过程:</p><ul><li>[-a] 激活某一条引导</li><li>[-A] 反激活</li><li>[-o] 对bootnum排序</li><li>[-O] 删除bootnum排序</li><li>[-t] 设置EFI超时时间</li><li>[-T] 删除EFI超时时间</li></ul></li></ol><p>efibootmgr的常用操作差不多就这些,man手册其实写的很明白,这里主要是记录一下添加一条新引导的方式,方便自己灵活控制系统加载,比如用来Clover来引导Hachintosh:P.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x81-efibootmgr的作用&quot;&gt;&lt;a href=&quot;#0x81-efibootmgr的作用&quot; class=&quot;headerlink&quot; title=&quot;0x81 efibootmgr的作用&quot;&gt;&lt;/a&gt;0x81 efibootmgr的作用&lt;/h3&gt;&lt;p&gt;相比校传统的
      
    
    </summary>
    
    
      <category term="efibootmgr" scheme="https://fioneragh.github.io/tags/efibootmgr/"/>
    
      <category term="UEFI" scheme="https://fioneragh.github.io/tags/UEFI/"/>
    
  </entry>
  
  <entry>
    <title>使用inobounce移除iOS的bounce效果</title>
    <link href="https://fioneragh.github.io/2017/11/16/%E4%BD%BF%E7%94%A8inobounce%E7%A7%BB%E9%99%A4iOS%E7%9A%84bounce%E6%95%88%E6%9E%9C/"/>
    <id>https://fioneragh.github.io/2017/11/16/使用inobounce移除iOS的bounce效果/</id>
    <published>2017-11-16T10:11:30.000Z</published>
    <updated>2019-01-16T04:46:38.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-问题来源"><a href="#0x81-问题来源" class="headerlink" title="0x81 问题来源"></a>0x81 问题来源</h3><p>iOS的浏览器有个让开发人员非常诟病的地方–Bounce效果,从用户的角度讲,这个效果的观感对用户来说体验确实还不错,但是会出现页面整体滚走的状况,导致页面内的滚动失效.</p><h3 id="0x82-inobounce"><a href="#0x82-inobounce" class="headerlink" title="0x82 inobounce"></a>0x82 inobounce</h3><p>inobounce是一个解决这种弹簧效果的库,这个库的代码很简单,进行的工作也很纯,就是判断在满足某些条件的时候,监听’touchmove’事件并阻止该滚动事件的发生.</p><p>inobounce.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable by default if the browser supports -webkit-overflow-scrolling</span></span><br><span class="line"><span class="comment">// Test this by setting the property with JavaScript on an element that exists in the DOM</span></span><br><span class="line"><span class="comment">// Then, see if the property is reflected in the computed style</span></span><br><span class="line"><span class="keyword">var</span> testDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.documentElement.appendChild(testDiv);</span><br><span class="line">testDiv.style.WebkitOverflowScrolling = <span class="string">'touch'</span>;</span><br><span class="line"><span class="keyword">var</span> scrollSupport = <span class="string">'getComputedStyle'</span> <span class="keyword">in</span> <span class="built_in">window</span> &amp;&amp; <span class="built_in">window</span>.getComputedStyle(testDiv)[<span class="string">'-webkit-overflow-scrolling'</span>] === <span class="string">'touch'</span>;</span><br><span class="line"><span class="built_in">document</span>.documentElement.removeChild(testDiv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (scrollSupport) &#123;</span><br><span class="line">    enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要创建了一个testDiv去验证浏览器是否支持’-webkit-overflow-scrolling=touch’这一特性,如果支持则启用事件监听:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> enable = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Listen to a couple key touch events</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'touchstart'</span>, handleTouchstart, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'touchmove'</span>, handleTouchmove, <span class="literal">false</span>);</span><br><span class="line">    enabled = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>handleTouchmove方法就是监听事件的具体处理方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scrolling = style.getPropertyValue(<span class="string">'-webkit-overflow-scrolling'</span>);</span><br><span class="line"><span class="keyword">var</span> overflowY = style.getPropertyValue(<span class="string">'overflow-y'</span>);</span><br><span class="line"><span class="keyword">var</span> height = <span class="built_in">parseInt</span>(style.getPropertyValue(<span class="string">'height'</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine if the element should scroll</span></span><br><span class="line"><span class="keyword">var</span> isScrollable = scrolling === <span class="string">'touch'</span> &amp;&amp; (overflowY === <span class="string">'auto'</span> || overflowY === <span class="string">'scroll'</span>);</span><br><span class="line"><span class="keyword">var</span> canScroll = el.scrollHeight &gt; el.offsetHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isScrollable &amp;&amp; canScroll) &#123;</span><br><span class="line">    <span class="comment">// Get the current Y position of the touch</span></span><br><span class="line">    <span class="keyword">var</span> curY = evt.touches ? evt.touches[<span class="number">0</span>].screenY : evt.screenY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine if the user is trying to scroll past the top or bottom</span></span><br><span class="line">    <span class="comment">// In this case, the window will bounce, so we have to prevent scrolling completely</span></span><br><span class="line">    <span class="keyword">var</span> isAtTop = (startY &lt;= curY &amp;&amp; el.scrollTop === <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> isAtBottom = (startY &gt;= curY &amp;&amp; el.scrollHeight - el.scrollTop === height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop a bounce bug when at the bottom or top of the scrollable element</span></span><br><span class="line">    <span class="keyword">if</span> (isAtTop || isAtBottom) &#123;</span><br><span class="line">        evt.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也很简单,去除DOM元素的属性判断它是能滚动的,然后计算它是否在顶部或底部,如果满足条件就禁止原本的事件,如此递归地处理所有节点便完成了禁止滚动的作用.</p><h3 id="0x83-缺陷与不足"><a href="#0x83-缺陷与不足" class="headerlink" title="0x83 缺陷与不足"></a>0x83 缺陷与不足</h3><p>inobounce能解决大部分状况,但是有的时候仍然会出现失败的情况,目前还没有更好的解决办法.但是使用了inobounce后又一个不足,就是webkit内核的’-webkit-overflow-scrolling’特性在处于文档顶和尾的时候都会失效,比如我们有个单页应用,它始终是填满viewport的,这时候页面内有个横向滑动的tab,当inobounce生效时,它将失去滑动的能力,解决办法就是为节点添加标记属性并忽略它们:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ignore data-scroll</span></span><br><span class="line"><span class="keyword">if</span>(el.getAttribute(<span class="string">'data-scroll'</span>) !== <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端适配的问题非常的多,当你在浏览器中行为正常,在移动端微信内嵌的WebView当中很可能就适配不好,要不断的调试和调整,微信端的问题还远不止这些,像Android上很多WebView版本过低不支持一些特性则更是让人头疼.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x81-问题来源&quot;&gt;&lt;a href=&quot;#0x81-问题来源&quot; class=&quot;headerlink&quot; title=&quot;0x81 问题来源&quot;&gt;&lt;/a&gt;0x81 问题来源&lt;/h3&gt;&lt;p&gt;iOS的浏览器有个让开发人员非常诟病的地方–Bounce效果,从用户的角度讲,这个效
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://fioneragh.github.io/tags/Vue/"/>
    
      <category term="inobounce" scheme="https://fioneragh.github.io/tags/inobounce/"/>
    
  </entry>
  
  <entry>
    <title>关于标点符号</title>
    <link href="https://fioneragh.github.io/2017/11/06/%E5%85%B3%E4%BA%8E%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7/"/>
    <id>https://fioneragh.github.io/2017/11/06/关于标点符号/</id>
    <published>2017-11-06T11:54:22.000Z</published>
    <updated>2019-01-16T04:46:38.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="凑数的标题"><a href="#凑数的标题" class="headerlink" title="凑数的标题"></a>凑数的标题</h3><p>由于实在苦于中英文标点的切换，以及如何控制字数呈现比较舒服的文字排列非常困难，所以我从前几篇笔记开始统一使用英文标点，再也没人担心我中英文标点切换有时候会根据上下文自动判别而超出预期的状况，所以终于可以好好的打字，诚恳的吐槽和愉悦的凑字数:P</p><h3 id="2018-05-10更新"><a href="#2018-05-10更新" class="headerlink" title="2018-05-10更新"></a>2018-05-10更新</h3><p>其实我后来又反悔了，因为中文标点在方块字的字里行间还是看起来更加舒服，随缘吧哈哈。（然后这篇文章的逗号又被我改了回去）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;凑数的标题&quot;&gt;&lt;a href=&quot;#凑数的标题&quot; class=&quot;headerlink&quot; title=&quot;凑数的标题&quot;&gt;&lt;/a&gt;凑数的标题&lt;/h3&gt;&lt;p&gt;由于实在苦于中英文标点的切换，以及如何控制字数呈现比较舒服的文字排列非常困难，所以我从前几篇笔记开始统一使用英文标点
      
    
    </summary>
    
    
      <category term="Ordinary" scheme="https://fioneragh.github.io/tags/Ordinary/"/>
    
  </entry>
  
  <entry>
    <title>偷懒的日子</title>
    <link href="https://fioneragh.github.io/2017/11/06/%E5%81%B7%E6%87%92%E7%9A%84%E6%97%A5%E5%AD%90/"/>
    <id>https://fioneragh.github.io/2017/11/06/偷懒的日子/</id>
    <published>2017-11-06T11:31:09.000Z</published>
    <updated>2019-01-16T04:46:38.782Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x80-如何科学的偷懒"><a href="#0x80-如何科学的偷懒" class="headerlink" title="0x80 如何科学的偷懒"></a>0x80 如何科学的偷懒</h3><p>距离上一次好好写写文章的日子已经很久了,大约一个半月以前的时候,自己再次产生了换个思路搞搞有意思的东西的想法,刚好又得意于某个环境(其实就是公司提供机会),便研究起了Hadoop生态圈,兴致勃勃地搞了几天.然而没过多久,我接到了重要的差遣,原本空闲的时间要拿出一部分甚至全部来投入到工作上,我觉得这是作为一个称职的员工应该做的.当然事实是我相当于出差一段时间,每天也是早出晚归,除了拿出点时间阅读点文章,真的没有时间再去玩点技术上的东西,同样的,我的笔记也就自然停止输入新的内容了.</p><p>说句实在话,最近这段时间不劳累是骗人的,但是也有一个好处,我不得不强迫自己按时吃早饭:P虽然我这段时间还是瘦了3/4斤= =.和socket打了大半个月交道,其实也算巩固了自己的知识面,到没大有什么太遗憾的,唯一要说的可能也就是这个自己所应坚持的笔记长时间停更,其实还是蛮内疚地.所以接下来一段时间我打算过一下之前写的东西,该补充补充,毕竟温故而知新,当然有啥有意思或好玩的,我还是会记下来,工作中的感悟可能也会写下来,毕竟我觉得我的工作性质已经有所变化了,它既不是我曾经坚持的,也不是我梦想拥有的,而人生就是这样,很多时候由不得己.</p><p>当然,还有很重要的一点,那就是我要重新开始学习安全相关的知识,我也要做ctf!!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x80-如何科学的偷懒&quot;&gt;&lt;a href=&quot;#0x80-如何科学的偷懒&quot; class=&quot;headerlink&quot; title=&quot;0x80 如何科学的偷懒&quot;&gt;&lt;/a&gt;0x80 如何科学的偷懒&lt;/h3&gt;&lt;p&gt;距离上一次好好写写文章的日子已经很久了,大约一个半月以前的时
      
    
    </summary>
    
    
      <category term="Ordinary" scheme="https://fioneragh.github.io/tags/Ordinary/"/>
    
  </entry>
  
  <entry>
    <title>JUnit下缺失MockJar的解决方法</title>
    <link href="https://fioneragh.github.io/2017/10/23/JUnit%E4%B8%8B%E7%BC%BA%E5%A4%B1MockJar%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://fioneragh.github.io/2017/10/23/JUnit下缺失MockJar的解决方法/</id>
    <published>2017-10-23T02:21:08.000Z</published>
    <updated>2019-01-16T04:46:38.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-TestCase执行失败"><a href="#0x81-TestCase执行失败" class="headerlink" title="0x81 TestCase执行失败"></a>0x81 TestCase执行失败</h3><p>最近升级几次Android Studio的beta版本经常遇到几个问题,JUnit执行单元测试时总是失败,原因是android包下的类找不到.虽然原则上讲JUnit的测试类中应该尽可能避免Android Framework的类出现,但有时候为了方便(偷懒)也会出现这种状况.然而神奇的是在之前的状况下是可以正常运行测试类的,因为IDE会生成对应的MockJar来模拟实际上不存的类,经过排查,发现Root Project下build文件夹中原应该生成的<code>mockable-android-[api]-*.jar</code>并没有出现,这也是导致TestCase执行失败的原因.</p><h3 id="0x82-手动重新生成MockJar"><a href="#0x82-手动重新生成MockJar" class="headerlink" title="0x82 手动重新生成MockJar"></a>0x82 手动重新生成MockJar</h3><p>我们在执行Gradle的Clear任务或Rebuild任务时,会删除build文件夹的内容重新生成,但是不管是配置有问题或者是IDE本身存在的bug,都有可能导致MockJar的生成失败,从而导致Android JUnit执行失败,如果要保证正常的执行测试用例,我们需要重新生成对应的文件.</p><p>修复方式通常有两种:</p><ol><li><p>通过拷贝其他工程生成的MockJar,因为对应api平台下IDE生成的MockJar通常是一致的,我们可以从其他工程中拷贝该文件到对应工程下,但是一但触发Clear任务会导致该文件被删除.</p></li><li><p>使用Gradle任务重新生成MockJar,可能个别版本的IDE或Gradle存在bug,导致MockJar没有生成,我们可以使用以下命令强制运行生成任务:</p></li></ol><ul><li><p><code>gradle mockableAndroidJar --info</code> 查看MockJar的状态信息</p></li><li><p><code>gradle mockableAndroidJar --rerun-tasks</code> 重新执行生成任务</p></li></ul><a id="more"></a><h3 id="0x83-“xxx”-is-not-mocked-method"><a href="#0x83-“xxx”-is-not-mocked-method" class="headerlink" title="0x83 “xxx” is not mocked method"></a>0x83 “xxx” is not mocked method</h3><p>在执行单元测试时还有可能遇到一个很奇葩的问题,某某类的某个方法没有被mock,对于这种状况其实也可以理解,某些情况下不存在模拟的普适性就不会被模拟,mockable默认只能保证不会出点ClassNotDefined异常,任何实例方法的调用都将导致<code>&quot;Method x in a.b.c.D not mocked. See http://g.co/androidstudio/not-mocked for details.&quot;</code>.</p><p>对于这种状况解决方法其实不难,我们可以自己模拟实现没有被mock的方法,也可以通过一个Gradle配置忽略结果让他返回默认结果从而保证测试代码能顺利执行下去:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testOptions &#123;</span><br><span class="line">    unitTests.returnDefaultValues = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于上面这种方式,只能用在其结果没有影响的情况下,不可作为解决问题的根本方式</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-TestCase执行失败&quot;&gt;&lt;a href=&quot;#0x81-TestCase执行失败&quot; class=&quot;headerlink&quot; title=&quot;0x81 TestCase执行失败&quot;&gt;&lt;/a&gt;0x81 TestCase执行失败&lt;/h3&gt;&lt;p&gt;最近升级几次Android Studio的beta版本经常遇到几个问题,JUnit执行单元测试时总是失败,原因是android包下的类找不到.虽然原则上讲JUnit的测试类中应该尽可能避免Android Framework的类出现,但有时候为了方便(偷懒)也会出现这种状况.然而神奇的是在之前的状况下是可以正常运行测试类的,因为IDE会生成对应的MockJar来模拟实际上不存的类,经过排查,发现Root Project下build文件夹中原应该生成的&lt;code&gt;mockable-android-[api]-*.jar&lt;/code&gt;并没有出现,这也是导致TestCase执行失败的原因.&lt;/p&gt;
&lt;h3 id=&quot;0x82-手动重新生成MockJar&quot;&gt;&lt;a href=&quot;#0x82-手动重新生成MockJar&quot; class=&quot;headerlink&quot; title=&quot;0x82 手动重新生成MockJar&quot;&gt;&lt;/a&gt;0x82 手动重新生成MockJar&lt;/h3&gt;&lt;p&gt;我们在执行Gradle的Clear任务或Rebuild任务时,会删除build文件夹的内容重新生成,但是不管是配置有问题或者是IDE本身存在的bug,都有可能导致MockJar的生成失败,从而导致Android JUnit执行失败,如果要保证正常的执行测试用例,我们需要重新生成对应的文件.&lt;/p&gt;
&lt;p&gt;修复方式通常有两种:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过拷贝其他工程生成的MockJar,因为对应api平台下IDE生成的MockJar通常是一致的,我们可以从其他工程中拷贝该文件到对应工程下,但是一但触发Clear任务会导致该文件被删除.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用Gradle任务重新生成MockJar,可能个别版本的IDE或Gradle存在bug,导致MockJar没有生成,我们可以使用以下命令强制运行生成任务:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;gradle mockableAndroidJar --info&lt;/code&gt; 查看MockJar的状态信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;gradle mockableAndroidJar --rerun-tasks&lt;/code&gt; 重新执行生成任务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JUnit" scheme="https://fioneragh.github.io/tags/JUnit/"/>
    
      <category term="Mock" scheme="https://fioneragh.github.io/tags/Mock/"/>
    
  </entry>
  
</feed>
